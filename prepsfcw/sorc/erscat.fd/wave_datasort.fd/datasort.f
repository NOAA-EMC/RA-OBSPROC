C$$$  MAIN PROGRAM DOCUMENTATION BLOCK
C
C MAIN PROGRAM: WAVE_DATASORT
C   PRGMMR: KEYSER           ORG: NP22        DATE: 2000-12-05
C
C ABSTRACT: PROCESSES THE ESA FAST DELIVERY SIGMA NAUGHTS
C   (MEASUREMENTS OF OCEAN SURFACE ROUGHNESS) FROM THE ERS-X
C   SATELLITE INTO OCEAN SURFACE WIND VECTORS.  DATA IS TIME SORTED
C   AND FLAGGED FOR POOR QUALITY DATA OVER LAND AND SEA ICE.  VECTOR
C   AMBIGUITY REMOVAL IS PERFORMED USING SUBROUTINES ADAPTED FROM
C   UKMET OFFICE AND THE CMOD4 EMPIRICAL TRANSFER FUNCTION (SEE
C   WOICESHYN, P. et al: "USE OF ERS-1 SCATTEROMETER DATA TO DERIVE
C   OCEAN SURFACE WINDS AT NMC, PREPRINTS, 13TH CONFERENCE ON WEATHER
C   ANALYSIS AND FORECASTING, VIENNA, VIRGINIA, AMERICAN
C   METEOROLOGICAL SOCIETY, 239-240").  A LOCAL CONTINUITY CHECK AND
C   FIT TO NCEP GLOBAL MODEL 10 M WIND FIELD ARE INCLUDED IN THE
C   PROCESSING SCHEME DEVELOPED BY P. WOICESHYN.  RESULTING WIND
C   VECTORS OBTAINED USING CMOD4 ARE PACKED IN NCEP BUFR FILE. THESE
C   REPROCESSED REPORTS ALSO CONTAIN A UNIQUE ID GENERATED HERE.
C
C PROGRAM HISTORY LOG:
C
C 1993-04-01 PETER WOICESHYN -- ORIGINAL AUTHOR
C 1993-04-13 R. TEBOULLE -- UPDATED TO ADD TIME SORTING
C 1994-06-21 C. PETERS -- UPDATED TO ADD BUFR ENCODING OF WINDS,
C            DOCBLOCK
C 1994-11-18 C. PETERS -- UPDATED TO CHANGE FILE ASSIGNMENT NUMBERS
C            TO CONFORM TO NMC HANDBOOK RULES, ADDED CHECK ON BUFR
C            MESSAGE
C 1995-05-03 C. PETERS -- UPDATED TO ADD ESA WIND SPEED, DIRECTION TO
C            BUFR FILE OUTPUT
C 1997-04-21 D. KEYSER -- MODIFIED IN-LINE SUBROUTINE W3FI85 TO STOP
C            WITH C.CODE 88 TO AVOID INFINITE LOOP WHEN LOGIC DROPS
C            TO STATEMENT 5500 X NUMBER OF TIMES FOR REASONS YET
C            UNKNOWN (WHERE X IS NUMBER OF TRANSFERS TO STATEMENT 5500
C            SUCH THAT THE NUMBER OF SUBSETS LEFT TO PROCESS HAS BEEN
C            REDUCED TO A NEGATIVE NUMBER)
C 1998-08-31 C. PETERS -- MODIFIED FOR Y2K COMPLIANCE
C 1998-10-06 D. KEYSER AND C. PETERS -- MODIFIED TO READ REVISED INPUT
C            FILE WITH 4-DIGIT YEAR FOR REPORTS; TIME-SORT VARIABLE
C            MODIFIED TO BE INTEGER IN FORM YYYYMMDDHHMMSS (ENSURES
C            THAT SORT WORKS PROPERLY ACROSS MONTH AND YEAR BOUNDARIES
C            AND AFTER 1/1/2000); FULL YEAR COPIED DIRECTLY TO OUTPUT
C            BUFR FILE (WINDOWING FOR 2-DIGIT YEAR REMOVED)
C 1999-02-16 D. KEYSER -- MODIFIED TO OUTPUT DATA IN NCEP BUFR FILE AS
C            WELL AS WMO ("CAVANAUGH") BUFR FILE IF REQUESTED
C 1999-07-16 D. KEYSER -- MODIFIED TO OUTPUT DATA ONLY IN NCEP BUFR
C            FILE AS PART OF CONVERSION TO IBM-SP
C 1999-08-16 D. KEYSER -- FURTHER MODIFICATIONS FOR IBM-SP
C 2000-07-21 D. KEYSER -- REPLACED NON-ZERO STOPS WITH CALLS TO W3LIB
C            ROUTINE ERREXIT WHICH ALLOWS THE NON-ZERO STATUS TO BE
C            TRANSFERRED BACK TO THE UNIX SCRIPT (AND MAKES THE CODE
C            MORE PORTABLE)
C 2000-12-05 D. KEYSER -- CORRECTED ERROR WHICH ALWAYS SKIPPED THE
C            ENCODING OF THE LAST REPORT INTO BUFR FILE; STREAMLINED
C            CODE A BIT; REMOVED SOME UNNEEDED LOGIC RELATED TO OLD
C            WMO BUFR FILE PROCESSING; ADDED ENCODING OF REPORT ID
C            (RPID) INTO OUTPUT BUFR FILE
C
C USAGE:
C   INPUT FILES:
C     UNIT 12  - FILE CONTAINING QUALITY CONTROLLED CO-LOCATED ERS
C                SCATTEROMETER AND NCEP GLOBAL FIRST GUESS VARIABLES
C                (GENERATED BY PROGRAM WAVE_DATAQC)
C     UNIT 20  - BUFR MNEMONIC TABLE (NEEDED TO PRODUCE NCEP BUFR FILE)
C     UNIT 30  - NCEP BUFR DATA DUMP CONTAINING ORIGINAL FORM OF ERS
C                DATA
C     UNIT 40  - CMOD_DBLUT - LOOK UP TABLE GENERATED FROM THE CMOD4
C                TRANSFER FUNCTION
C     UNIT 42  - CMOD_QSLUT - LOOK UP TABLE GENERATED FROM THE CMOD4
C                TRANSFER FUNCTION
C     UNIT 91  - ERS2.SO   WORKING FILE
C     UNIT 92  - ERS2.IN   WORKING FILE
C     UNIT 93  - ERS2.94ER WORKING FILE
C
C   OUTPUT FILES:
C     UNIT 06  - STANDARD OUTPUT PRINT
C     UNIT 60  - NCEP BUFR DATA DUMP CONTAINING FINAL FORM OF ERS
C                WIND DATA WITH UNIQUE REPORT IDS
C     UNIT 91  - ERS2.SO   WORKING FILE
C     UNIT 92  - ERS2.IN   WORKING FILE
C     UNIT 93  - ERS2.94ER WORKING FILE
C
C   SUBPROGRAMS CALLED:
C     UNIQUE:  - AVANG    DMODAL   FIT3     PROB     QSPEED   RANK
C              - RESID    RETPROB  RKONBGD  RKONLFD  RKONRES  SLICE
C              - TSIGDB   WINRET   EXTFIT   SORTDT   CLCSEC
C     LIBRARY
C       W3LIB    - W3TAGB   W3TAGE   ERREXIT
C       BUFRLIB  - DATELEN  OPENBF   READMG   CLOSBF   COPYMG
C                - OPENMG   UFBINT   WRITSB   UFBCNT   CLOSMG
C
C   EXIT STATES:
C     COND =   0 - SUCCESSFUL RUN
C          =  33 - ERROR READING INPUT FILE IN UNIT 12
C          =  61 - ERROR OBTAINING CENTER DATE FROM FIRST BUFR MESSAGE
C                  IN UNIT 30
C          =  62 - ERROR OBTAINING DUMP DATE FROM SECOND BUFR MESSAGE
C                  IN UNIT 30
C
C REMARKS: NONE.
C          
C ATTRIBUTES:
C   LANGUAGE: FORTRAN 90
C   MACHINE : IBM-SP
C
C$$$

      PROGRAM WAVE_DATASORT

      PARAMETER ( NB = 3, NS = 4, NC = 19, NO = NC*NC , N1 = NO+1 )
      PARAMETER ( MAXPRD = 1000, MSMAX= 15 )

      PARAMETER (MAXD=20)

C     NUMBER OF BLOCKS
C     ================

      PARAMETER ( NBLOCK = 200, MAXROW = NC*NBLOCK, MXROW = 19*MAXROW )

C     USED FOR THE INTERMEDIATE READ
C     ==============================

      INTEGER XIBB,XIROW,XJCELL,XSID,XPCTRK,XIID,XIYMD,XIHMS,XPCDM,CDATE

C     NEXT ARRAYS ARE USED TO SAVE THE SORTED DATA THAT WILL BE
C     WRITTEN IN THE END TO THE OUTPUT (SORTED) FILE
C     =========================================================

      INTEGER(8) IDATE(NBLOCK)
      INTEGER SID(N1,NBLOCK),PCTRK(N1,NBLOCK),IID(N1,NBLOCK),
     $ IYMD(N1,NBLOCK),IHMS(N1,NBLOCK),PCDM(N1,NBLOCK),NP(NBLOCK),
     $ IBB(N1,NBLOCK),IBC(NBLOCK),NPC(NBLOCK),ICONF(NBLOCK),
     $ IROW(N1,NBLOCK),JCELL(N1,NBLOCK)
      REAL PCLT(N1,NBLOCK), PCLN(N1,NBLOCK),VE(N1,NBLOCK),DE(N1,NBLOCK),
     $ VM(N1,NBLOCK),DM(N1,NBLOCK),SST(N1,NBLOCK),AIRT(N1,NBLOCK),
     $ RHUM(N1,NBLOCK)
      REAL AI(0:NB-1,N1,NBLOCK),BA(0:NB-1,N1,NBLOCK),
     $ S0(0:NB-1,N1,NBLOCK),KP(0:NB-1,N1,NBLOCK),MS(0:NB-1,N1,NBLOCK)

C     NEXT ARRAYS ARE TEMPORARY ARRAYS USED TO SAVE THE CURRENT
C     DATA THAT WAS READ IN AND WILL BE PUT IN THE RIGHT PLACE
C     IN THE PREVIOUS ARRAYS (AFTER SORTING)
C     =========================================================

      INTEGER(8) SIDATE
      INTEGER SSID(N1),SPCTRK(N1),SIID(N1),SIYMD(N1),SIHMS(N1),
     $ SPCDM(N1),SIBB(N1),SIROW(N1),SJCELL(N1)
      REAL SPCLT(N1), SPCLN(N1),SVE(N1),SDE(N1),SVM(N1),SDM(N1),
     $ SSST(N1),SAIRT(N1),SRHUM(N1)
      REAL SAI(0:NB-1,N1),SBA(0:NB-1,N1),SS0(0:NB-1,N1),SKP(0:NB-1,N1),
     $ SMS(0:NB-1,N1)

C     NEXT ARRAYS ARE ALSO USED TO WRITE THE SORTED DATA THAT WILL BE
C     WRITTEN OUT OR USED INTERNALLY IN THIS MAIN PROGRAM
C     ===============================================================

      INTEGER NS4(N1,NBLOCK),IBET(N1,NBLOCK)
      INTEGER SS1,SS2,SSS,DSS1,DSS2
                    
      REAL VS1(NS,N1,NBLOCK),DS1(NS,N1,NBLOCK),RS1(NS,N1,NBLOCK)
      REAL VS2(NS,N1,NBLOCK),DS2(NS,N1,NBLOCK),RS2(NS,N1,NBLOCK)
      REAL VSOL(1:NS),DSOL(1:NS),RSOL(1:NS)
      REAL YS0(0:NB-1),YAI(0:NB-1),YBA(0:NB-1),YKP(0:NB-1),YMS(0:NB-1)

C     DUMMY ARRAY VARIABLES TO ACCOUNT FOR MISSING DATA
C     =================================================

      INTEGER  IPCDX(NC,NC,NBLOCK)
      INTEGER  IBCX(NC,NC,NBLOCK),NPCX(NC,NC,NBLOCK),
     $ ICONFX(NC,NC,NBLOCK),IROWX(NC,NC,NBLOCK),JCELLX(NC,NC,NBLOCK),
     $ PCTRKX(NC,NC,NBLOCK),NS4X(NC,NC,NBLOCK),IBETX(NC,NC,NBLOCK),
     $ IBHMSX(NC,NC,NBLOCK),IBYMDX(NC,NC,NBLOCK)

      REAL VSX(NS,NC,NC,NBLOCK),DSX(NS,NC,NC,NBLOCK)
      REAL RSX(NS,NC,NC,NBLOCK),DFX(NC,NC,NBLOCK)
      REAL PCLTX(NC,NC,NBLOCK),PCLNX(NC,NC,NBLOCK),VEX(NC,NC,NBLOCK),
     $ DEX(NC,NC,NBLOCK),VMX(NC,NC,NBLOCK),DMX(NC,NC,NBLOCK),
     $ BAX(NC,NC,NBLOCK)

C     NEXT ARRAYS ARE USED TO WRITE THE SORTED DATA THAT WILL BE
C     WRITTEN OUT OR USED INTERNALLY IN THIS MAIN PROGRAM WITH SLICE
C     ==============================================================

      INTEGER IBEGIN(NBLOCK)
      INTEGER ILAST(NBLOCK)
      INTEGER NROW(MAXROW)

C     NEXT, DIMENSION & DECLARE ARRAYS FOR THE BUFR-IZATION OF OUTPUT
C     ===============================================================

      REAL    RDATA(MAXD)
      CHARACTER*8  SUBSET,STNID
      REAL(8)  RDATA_8(MAXD),RPID_8
      INTEGER  ICDATE(5),IDDATE(5)
      EQUIVALENCE  (STNID,RPID_8)

C     ARRAY VARIABLES PRIOR TO SLICE -- & AFTER ALSO
C     ==============================================

      INTEGER  IBCY(NC,MAXROW),NPCY(NC,MAXROW),ICONFY(NC,MAXROW),
     $ IROWY(NC,MAXROW),JCELLY(NC,MAXROW),PCTRKY(NC,MAXROW),
     $ NS4Y(NC,MAXROW),IBETY(NC,MAXROW),IBHMSY(NC,MAXROW),
     $ IBYMDY(NC,MAXROW)
      INTEGER IPCD(NC,MAXROW)
      REAL VS3(NS,NC,MAXROW),DS3(NS,NC,MAXROW),RS3(NS,NC,MAXROW)
      REAL DF(NC,MAXROW)
      REAL PCLTY(NC,MAXROW),PCLNY(NC,MAXROW),VEY(NC,MAXROW),
     $ DEY(NC,MAXROW),VMY(NC,MAXROW),DMY(NC,MAXROW),BAY(NC,MAXROW)

C     ARRAY VARIABLES AFTER SLICE -  NEEDED FOR POSTING
C     =================================================

      REAL RYEAR(MXROW),RMONTH(MXROW),RDAY(MXROW),RHOUR(MXROW),
     $ RMINUTE(MXROW),RSECOND(MXROW)

      REAL LAT_Y(MXROW),LON_X(MXROW),E_SPEED(MXROW),E_DIR(MXROW),
     $ ESA_SP(MXROW),ESA_DR(MXROW)

C     KEEP LOW AND HIGH VALUES FOR EACH POSSIBLE CELL
C     ===============================================

      REAL CELLOW(19),CELHGH(19)

      DATA CELLOW /22.4,26.0,28.4,30.7,32.9,35.05,37.1,39.05,40.9,42.7,
     $             44.45,46.1,47.7,49.2,50.65,52.1,53.45,54.7,55.9/,
     $     CELHGH /26.0,28.4,30.7,32.9,35.05,37.1,39.05,40.9,42.7,44.45,
     $             46.1,47.7,49.2,50.65,52.1,53.45,54.7,55.9,58.0/

      CALL W3TAGB('WAVE_DATASORT',2000,0206,0061,'NP22')                  
      PRINT *, ' '
      PRINT *, '=====> WELCOME TO PROGRAM WAVE_DATASORT - ',
     $ 'VERSION: 12/05/2000'
      PRINT *, ' '

      IBLK  =    1
      IOYMD = -999
      IOHMS = -999

      JERR = 0

      DO WHILE (JERR.EQ.0)
         READ(12,ERR=8600,END=5500) XIBB,XIROW,XJCELL,XSID,XPCTRK,XIID,
     $    XIYMD, XIHMS,XPCLT,XPCLN,XAI0,XBA0,XS00,XKP0,XMS0,XAI1,XBA1,
     $    XS01,XKP1,XMS1,XAI2,XBA2,XS02,XKP2,XMS2,XVE,XDE,XPCDM,XVM,XDM,
     $    XSST,XAIRT,XRHUM

C     NEW BLOCK IS COMING IF TIME CHANGES
C     ===================================

         IF (IOYMD.NE.XIYMD .OR. IOHMS.NE.XIHMS) THEN
            IBLK = IBLK + 1
            IOYMD = XIYMD
            IOHMS = XIHMS
         ENDIF
         WRITE (92) IBLK,XIROW,XJCELL,XSID,XPCTRK,XIID,XIYMD,XIHMS,
     $    XPCLT,XPCLN,XAI0,XBA0,XS00,XKP0,XMS0,XAI1,XBA1,XS01,XKP1,XMS1,
     $    XAI2,XBA2,XS02,XKP2,XMS2,XVE,XDE,XPCDM,XVM,XDM,XSST,XAIRT,
     $    XRHUM
      ENDDO

 5500 CONTINUE

      REWIND 92

      NSOLIN  = 0
      NSOLOUT = 0

      ISORTF = 91  ! THE SORTED OUTPUT FILE

      IBLOCK = 0   ! NEXT BLOCK NUMBER TO SAVE DATA IN
      ISSI   = 0   ! SAVE I INDEX FOR LATER USE
      IEFLAG = 0   ! END OF INPUT FILE FLAG
      IBSAVE = 0

      LOOP1: DO  WHILE (JERR.EQ.0)
         ISAVEB = 1   ! NEXT BLOCK NUMBER TO SAVE DATA IN
         I = 1

C     GET THE NEXT BLOCK OF DATA ALONG THE ERS TRACK
C     ==============================================

         IBSAVE = IBSAVE + 1
         IF (IBSAVE.GT.NBLOCK) THEN
            PRINT *,' arrays are full, finished reading ',NBLOCK,
     $       ' blocks'
            PRINT *,' ********************************************'
            IBSAVE = NBLOCK
            WRITE(93,*) '  '
            WRITE(93,*) '  No. of Records In = ',NSOLIN
            IEFLAG = 1
            GO TO 879
         END IF

         IF (ISSI.NE.0) THEN
            WRITE(93,*) 'beginning of the new block, take from issi = ',
     $       ISSI
            SIBB(1)   = SIBB(ISSI)
            SIROW(1)  = SIROW(ISSI)  
            SJCELL(1) = SJCELL(ISSI)
            SSID(1)   = SSID(ISSI)
            SPCTRK(1) = SPCTRK(ISSI)
            SIID(1)   = SIID(ISSI)
            SIYMD(1)  = SIYMD(ISSI)
            SIHMS(1)  = SIHMS(ISSI)
            SPCLT(1)  = SPCLT(ISSI)
            SPCLN(1)  = SPCLN(ISSI)
            SAI(0,1)  = SAI(0,ISSI)
            SBA(0,1)  = SBA(0,ISSI)
            SS0(0,1)  = SS0(0,ISSI)
            SKP(0,1)  = SKP(0,ISSI)
            SMS(0,1)  = SMS(0,ISSI)
            SAI(1,1)  = SAI(1,ISSI)
            SBA(1,1)  = SBA(1,ISSI)
            SS0(1,1)  = SS0(1,ISSI)
            SKP(1,1)  = SKP(1,ISSI)
            SMS(1,1)  = SMS(1,ISSI)
            SAI(2,1)  = SAI(2,ISSI)
            SBA(2,1)  = SBA(2,ISSI)
            SS0(2,1)  = SS0(2,ISSI)
            SKP(2,1)  = SKP(2,ISSI)
            SMS(2,1)  = SMS(2,ISSI)
            SVE(1)    = SVE(ISSI)
            SDE(1)    = SDE(ISSI)
            SPCDM(1)  = SPCDM(ISSI)
            SVM(1)    = SVM(ISSI)
            SDM(1)    = SDM(ISSI)
            SSST(1)   = SSST(ISSI)
            SAIRT(1)  = SAIRT(ISSI)
            SRHUM(1)  = SRHUM(ISSI)
            ISSI = 0

C     TIME "BUBBLE" SORTING OF QC FILTERED TIME-UNSORTED ERS DATA
C     ===========================================================

            IBLOCK = SIBB(1)
            WRITE(93,*) 'new block: ibsave(count),iblock(read in)= ',
     $       IBSAVE,', ',IBLOCK
            ISAVEB = 0
            IF (SIBB(1).NE.IBLOCK) GO TO 879
            SIDATE = (IYR*10000000000_8) + (IMO*100000000) + 
     $       (IDY*1000000) + (IHR*10000) + (IMIN*100) + ISEC
            I = 2
            NSOLIN = NSOLIN + 1
         ENDIF

         LOOP1n1: DO  WHILE (JERR.EQ.0)

C     NOW READING DATA FROM TIME-UNSORTED BLOCK RENAMED UNIT 92
C     =========================================================

            READ(92,END=500,ERR=800) SIBB(I),SIROW(I),SJCELL(I),SSID(I),
     $       SPCTRK(I),SIID(I),SIYMD(I), SIHMS(I),SPCLT(I),SPCLN(I),
     $       SAI(0,I),SBA(0,I),SS0(0,I),SKP(0,I),SMS(0,I),SAI(1,I),
     $       SBA(1,I),SS0(1,I),SKP(1,I),SMS(1,I),SAI(2,I),SBA(2,I),
     $       SS0(2,I),SKP(2,I),SMS(2,I),SVE(I),SDE(I),SPCDM(I),SVM(I),
     $       SDM(I),SSST(I),SAIRT(I),SRHUM(I)

C     REDUCE PARAM SIYMD TO IYR,IMO,IDY, & PARAM SIHMS TO IHR,IMIN,ISEC
C     =================================================================

            IYR   = SIYMD(I)/10000
            IMON  = (SIYMD(I) - IYR*10000)
            IMO   = IMON/100
            IDY   = (IMON - IMO*100)
            IHR   = SIHMS(I)/10000
            IMINU = (SIHMS(I) -IHR*10000)
            IMIN  = IMINU/100
            ISEC  = (IMINU - IMIN*100)

C     NOW FILTERING OUT DATA FOR USER SELECTED MAX KP, SKP
C     ====================================================

            DO IJ = 0, NB-1
               IF (SKP(IJ,I).LT.0. .or. SKP(IJ,I).GT.10.) CYCLE LOOP1n1
            ENDDO

C     NOW FILTERING OUT DATA FOR MISSING SHOTS TOTAL .GT. MSMAX = 15
C     ==============================================================

            MSTOT = 0
            DO IJ = 0, NB-1
               MSTOT = MSTOT + ABS(SMS(IJ,I))
            ENDDO
            IF ( MSTOT .GT. MSMAX) CYCLE LOOP1n1

C     TIME "BUBBLE" SORTING OF QC FILTERED TIME-UNSORTED ERS DATA
C     ===========================================================

            IF (ISAVEB.EQ.1) THEN
               IBLOCK = SIBB(I)
               WRITE(93,*) 'new block: ibsave(count),iblock(read in)= ',
     $          IBSAVE,', ',IBLOCK
               ISAVEB = 0
            ENDIF
            IF (SIBB(I).NE.IBLOCK) GO TO 879
            IF (I.EQ.1)  SIDATE = (IYR*10000000000_8) + (IMO*100000000)
     $       + (IDY*1000000) + (IHR*10000) + (IMIN*100) + ISEC
            I = I + 1
            NSOLIN = NSOLIN + 1
         ENDDO LOOP1n1

 800     CONTINUE
         WRITE(93,*) ' some kind of error on file 10, sorry'
 500     CONTINUE
         WRITE(93,*) '  '
         WRITE(93,*) '  No. of Records In = ',NSOLIN
         IEFLAG = 1

 879     CONTINUE

         ISSI = I  ! SAVE I INDEX

         NPSAVE = I - 1

CCCC     PRINT *,'in 879 npsave=',NP

C     ================================
C             BUBBLE SORTING
C     ================================

C     GET THE BLOCK INDEX THAT THE NEW DATA SHOULD ENTER INTO
C     ========================================================

C     SIDATE = DATE AND TIME OF CURRENT BLOCK
C     =======================================

         CALL SORTDT (IBSAVE,SIDATE,IDATE,INDEX)

C     CHECK TO SEE IF WE HAVE BLOCKS WITHIN 30 SECS OF EACH OTHER
C     I.E., DUPLICATE BLOCKS
C     ========================================================

         IF(IBSAVE .GT. 1) THEN
            SS2 = -999
            SS1 = -999
            ID1 = -999  ! DAY1
            ID2 = -999  ! DAY2
 
            CALL CLCSEC(SIHMS(1),SSS)

            IF(INDEX .GT. 1) THEN
               CALL CLCSEC(IHMS(1,INDEX - 1),SS1)
               IYMDD = IYMD(1,INDEX -1)
               ID1 = IYMDD - IYMDD/100*100
               IF(ID1 .LT. IDY) SSS = SSS + 3600*24
               DSS1 = ABS(SSS - SS1)
            ENDIF

            IF(INDEX .LT. IBSAVE) THEN
               CALL CLCSEC(IHMS(1,INDEX),SS2)
               IYMDD = IYMD(1,INDEX)
               ID2 = IYMDD - IYMDD/100*100
               IF(ID2 .LT. IDY) SS2 = SSS + 3600*24
               DSS2 = ABS(SSS - SS2)
            ENDIF

            IF((SS1 .NE. -999.0 .AND. DSS1 .LE. 30.0) .OR.
     $         (SS2 .NE. -999.0 .AND. DSS2 .LE. 30.0)) THEN
               IBSAVE = IBSAVE - 1
               IF (IEFLAG.EQ.0) CYCLE LOOP1
            ENDIF
         ENDIF     

C    END OF CHECKING FOR IDENTICAL BLOCKS & TIMES DIFFER < 30 SEC
C    ============================================================

         IF (IBSAVE.GT.INDEX) THEN
            DO IB=IBSAVE,INDEX+1,-1
CCC            PRINT *,'in loop,ib=',IB
               DO I = 1,NP(IB-1)
                  IBB(I,IB)   = IBB(I,IB-1)
                  IROW(I,IB)  = IROW(I,IB-1)
                  JCELL(I,IB) = JCELL(I,IB-1)
                  SID(I,IB)   = SID(I,IB-1)
                  PCTRK(I,IB) = PCTRK(I,IB-1)
                  IID(I,IB)   = IID(I,IB-1)
                  IYMD(I,IB)  = IYMD(I,IB-1)
                  IHMS(I,IB)  = IHMS(I,IB-1)
                  PCLT(I,IB)  = PCLT(I,IB-1)
                  PCLN(I,IB)  = PCLN(I,IB-1)
                  AI(0,I,IB)  = AI(0,I,IB-1)
                  BA(0,I,IB)  = BA(0,I,IB-1)
                  S0(0,I,IB)  = S0(0,I,IB-1)
                  KP(0,I,IB)  = KP(0,I,IB-1)
                  MS(0,I,IB)  = MS(0,I,IB-1)
                  AI(1,I,IB)  = AI(1,I,IB-1)
                  BA(1,I,IB)  = BA(1,I,IB-1)
                  S0(1,I,IB)  = S0(1,I,IB-1)
                  KP(1,I,IB)  = KP(1,I,IB-1)
                  MS(1,I,IB)  = MS(1,I,IB-1)
                  AI(2,I,IB)  = AI(2,I,IB-1)
                  BA(2,I,IB)  = BA(2,I,IB-1)
                  S0(2,I,IB)  = S0(2,I,IB-1)
                  KP(2,I,IB)  = KP(2,I,IB-1)
                  MS(2,I,IB)  = MS(2,I,IB-1)
                  VE(I,IB)    = VE(I,IB-1)
                  DE(I,IB)    = DE(I,IB-1)
                  PCDM(I,IB)  = PCDM(I,IB-1)
                  VM(I,IB)    = VM(I,IB-1)
                  DM(I,IB)    = DM(I,IB-1)
                  SST(I,IB)   = SST(I,IB-1)
                  AIRT(I,IB)  = AIRT(I,IB-1)
                  RHUM(I,IB)  = RHUM(I,IB-1)
               ENDDO
               NP(IB) = NP(IB-1)
               IDATE(IB) = IDATE(IB-1)
            ENDDO
         ENDIF

         NP(INDEX) = NPSAVE
CCC      PRINT *,'np=',NP
         IBB(1:NP(INDEX),INDEX)   = SIBB(1:NP(INDEX))
         IROW(1:NP(INDEX),INDEX)  = SIROW(1:NP(INDEX))
         JCELL(1:NP(INDEX),INDEX) = SJCELL(1:NP(INDEX))
         SID(1:NP(INDEX),INDEX)   = SSID(1:NP(INDEX))
         PCTRK(1:NP(INDEX),INDEX) = SPCTRK(1:NP(INDEX))
         IID(1:NP(INDEX),INDEX)   = SIID(1:NP(INDEX))
         IYMD(1:NP(INDEX),INDEX)  = SIYMD(1:NP(INDEX))
         IHMS(1:NP(INDEX),INDEX)  = SIHMS(1:NP(INDEX))
         PCLT(1:NP(INDEX),INDEX)  = SPCLT(1:NP(INDEX))
         PCLN(1:NP(INDEX),INDEX)  = SPCLN(1:NP(INDEX))
         AI(0,1:NP(INDEX),INDEX)  = SAI(0,1:NP(INDEX))
         BA(0,1:NP(INDEX),INDEX)  = SBA(0,1:NP(INDEX))
         S0(0,1:NP(INDEX),INDEX)  = SS0(0,1:NP(INDEX))
         KP(0,1:NP(INDEX),INDEX)  = SKP(0,1:NP(INDEX))
         MS(0,1:NP(INDEX),INDEX)  = SMS(0,1:NP(INDEX))
         AI(1,1:NP(INDEX),INDEX)  = SAI(1,1:NP(INDEX))
         BA(1,1:NP(INDEX),INDEX)  = SBA(1,1:NP(INDEX))
         S0(1,1:NP(INDEX),INDEX)  = SS0(1,1:NP(INDEX))
         KP(1,1:NP(INDEX),INDEX)  = SKP(1,1:NP(INDEX))
         MS(1,1:NP(INDEX),INDEX)  = SMS(1,1:NP(INDEX))
         AI(2,1:NP(INDEX),INDEX)  = SAI(2,1:NP(INDEX))
         BA(2,1:NP(INDEX),INDEX)  = SBA(2,1:NP(INDEX))
         S0(2,1:NP(INDEX),INDEX)  = SS0(2,1:NP(INDEX))
         KP(2,1:NP(INDEX),INDEX)  = SKP(2,1:NP(INDEX))
         MS(2,1:NP(INDEX),INDEX)  = SMS(2,1:NP(INDEX))
         VE(1:NP(INDEX),INDEX)    = SVE(1:NP(INDEX))
         DE(1:NP(INDEX),INDEX)    = SDE(1:NP(INDEX))
         PCDM(1:NP(INDEX),INDEX)  = SPCDM(1:NP(INDEX))
         VM(1:NP(INDEX),INDEX)    = SVM(1:NP(INDEX))
         DM(1:NP(INDEX),INDEX)    = SDM(1:NP(INDEX))
         SST(1:NP(INDEX),INDEX)   = SSST(1:NP(INDEX))
         AIRT(1:NP(INDEX),INDEX)  = SAIRT(1:NP(INDEX))
         RHUM(1:NP(INDEX),INDEX)  = SRHUM(1:NP(INDEX))

         IDATE(INDEX) = SIDATE

         IF (IEFLAG.NE.0) EXIT LOOP1
      ENDDO LOOP1

C     IB = NEW BLOCK INDEX = 1,2,....IBSAVE
C     IBB( , ) = OLD BLOCK INDEX BEFORE THE SORTING
C     ICONTF = A FLAG INDICATING THAT THE CURRENT BLOCK IS
C              CONTIGUOUS AFTER THE PREVIOUS ONE WHEN EQ. 1
C     ======================================================

C     NOW WRITING FILE HEADER & ANALYSIS TIME ON INTERMED. (OUTPUT) FILE
C     ==================================================================
CCC   WRITE (ISORTF,123) CDATE
CCC   WRITE (ISORTF) CDATE
 123  FORMAT (//'    ERS1 SCATTEROMETER AND NCEP MODEL'/4X,'MODEL DATE',
     $ ' = ',I8/' ==================================='///)

C     CHECK TO SEE IF BLOCKS ARE CONTIGUOUS, 0 = NO, 1 = YES
C     ======================================================

      DO IB = 1,IBSAVE
         ICONTF = 0
         IF (IB.NE.1) THEN
            IYMD1 = IYMD(1,IB-1)         ! PREVIOUS DATE
            IYMD2 = IYMD(1,IB)           ! CURRENT
            ID1 = IYMD1 - IYMD1/100 * 100
            ID2 = IYMD2 - IYMD2/100 * 100
CCC         PRINT *,'iymd1,id1,iymd2,id2=',IYMD1,',',ID1,',',IYMD2,',',
CCC  $       ID2

C     GET HOUR-MIN-SEC OF CURRENT BLOCK IN SECONDS
C     ============================================

            CALL CLCSEC (IHMS(1,IB),ISECT)

C     GET HOUR-MIN-SEC OF PREVIOUS BLOCK IN SECONDS
C     =============================================

            CALL CLCSEC (IHMS(1,IB-1),IPSECT)
CCC         PRINT *,'ipsect,isect=',IPSECT,',',ISECT
            IF (ID2.GT.ID1) ISECT = ISECT+ 3600*24

C     CONT. FLAG = ON IF TIME DIFFERENCE IS LESS THAN 1.5 MINUTES
C     ===========================================================

            IF ((ISECT - IPSECT).LE.90) ICONTF = 1
         ENDIF

CCC      PRINT *, '  isect = ', ISECT
CCC      PRINT *, ' ipsect = ', IPSECT

         DO I=1,NP(IB)
            ICONF(IB) = ICONTF
            IBC(IB)   = IB
            NPC(IB)   = NP(IB)

C     WRITING OUT TIME-SORTED SCATTEROMETER RECORDS TO DISK
C     =====================================================

            WRITE (ISORTF) IBC(IB),NPC(IB),ICONF(IB),IROW(I,IB),
     $       JCELL(I,IB),SID(I,IB),PCTRK(I,IB),IID(I,IB),IYMD(I,IB),
     $       IHMS(I,IB),PCLT(I,IB),PCLN(I,IB),AI(0,I,IB),BA(0,I,IB),
     $       S0(0,I,IB),KP(0,I,IB),MS(0,I,IB),AI(1,I,IB),BA(1,I,IB),
     $       S0(1,I,IB),KP(1,I,IB),MS(1,I,IB),AI(2,I,IB),BA(2,I,IB),
     $       S0(2,I,IB),KP(2,I,IB),MS(2,I,IB),VE(I,IB),DE(I,IB),
     $       PCDM(I,IB),VM(I,IB),DM(I,IB),SST(I,IB),AIRT(I,IB),
     $       RHUM(I,IB)

            NSOLOUT = NSOLOUT + 1
         ENDDO
      ENDDO

      WRITE(93,*) '  '
      WRITE(93,*) ' No. of Records out = ',NSOLOUT
      WRITE(93,*) '  '

C    ===================================================================
C           PROCESSING ERS S0'S TO WINDS CALLING WINRET & EXTFIT
C                           (WITH NOAA ANALYSIS)
C
C    A RECORD BY RECORD PROCESSING STAGE AFTER Q. CONTROL & TIME-SORTING
C    ===================================================================

      LOOP2: DO IBSC = 1, IBSAVE  ! TOTAL NO. OF BLOCKS
         IIICNT = 1
         LOOP2n1: DO III = 1, NO ! WHERE NO = 361, MAX NO. RECORDS IN
                                 ! BLOCK
            YS0(0:2) = S0(0:2,III,IBSC)
            YAI(0:2) = AI(0:2,III,IBSC)
            YBA(0:2) = BA(0:2,III,IBSC)
            YKP(0:2) = KP(0:2,III,IBSC)
            YMS(0:2) = MS(0:2,III,IBSC)

            IYPCDM = 0
            YPCLT = PCLT(III,IBSC)
            YPCLN = PCLN(III,IBSC)
            YVM = VM(III,IBSC)
            YDM = DM(III,IBSC)

            IBET(III,IBSC) = 0

            CALL WINRET(YS0,YAI,YBA,YKP,YMS,IYPCDM,VSOL,DSOL,RSOL,NVS) 

            VS1(1:4,III,IBSC) = VSOL(1:4)
            DS1(1:4,III,IBSC) = DSOL(1:4)
            RS1(1:4,III,IBSC) = RSOL(1:4)
 
            NS4(III,IBSC) = NVS

            CALL EXTFIT(YPCLT,YPCLN,IYPCDM,VSOL,DSOL,RSOL,YVM,YDM)

            VS2(1:4,III,IBSC) = VSOL(1:4)
            DS2(1:4,III,IBSC) = DSOL(1:4)
            RS2(1:4,III,IBSC) = RSOL(1:4)
 
            IIICNT = IIICNT + 1
            IF (IIICNT .GT. NPC(IBSC)) CYCLE LOOP2
         ENDDO LOOP2n1
      ENDDO LOOP2

      NSOL1 = 0

C     FILLING IN DUMMY ARRAY TO ACCOUNT FOR MISSING DATA
C     ==================================================

      VSX(1:NS,1:NC,1:NC,1:IBSAVE) =  51.0
      DSX(1:NS,1:NC,1:NC,1:IBSAVE) = 510.0
      RSX(1:NS,1:NC,1:NC,1:IBSAVE) =   0.0
      DFX(1:NC,1:NC,1:IBSAVE)      = 510.0
      IPCDX(1:NC,1:NC,1:IBSAVE)    =   0
      PCLTX(1:NC,1:NC,1:IBSAVE)    = 100.0
      PCLNX(1:NC,1:NC,1:IBSAVE)    = 510.0
      VEX(1:NC,1:NC,1:IBSAVE)      =  51.0
      DEX(1:NC,1:NC,1:IBSAVE)      = 510.0
      VMX(1:NC,1:NC,1:IBSAVE)      =  51.0
      DMX(1:NC,1:NC,1:IBSAVE)      = 510.0
      PCTRKX(1:NC,1:NC,1:IBSAVE)   = 510
      BAX(1:NC,1:NC,1:IBSAVE)      =   0.0
      NS4X(1:NC,1:NC,1:IBSAVE)     =   0
      IBETX(1:NC,1:NC,1:IBSAVE)    =   0
      IBHMSX(1:NC,1:NC,1:IBSAVE)   =   0
      IBYMDX(1:NC,1:NC,1:IBSAVE)   =   0

      DO I2B = 1,IBSAVE
         IBCX(1:NC,1:NC,I2B) = I2B
         NPCX(1:NC,1:NC,I2B) = NPC(I2B)
         ICONFX(1:NC,1:NC,I2B) = ICONF(I2B)
         DO I2R = 1,NC
            IROWX(1:NC,I2R,I2B) = I2R
            DO I2C = 1,NC
               JCELLX(I2C,I2R,I2B) = I2C
               NSOL1 = NSOL1 + 1
            ENDDO
         ENDDO
      ENDDO
 
      WRITE(93,*) ' '
      WRITE(93,*) ' no. of dummy records in array = ',NSOL1

C     OVER-WRITE DUMMY ARRAY VALUES W/ REAL DATA, & ADD FULL DATA ARRAYS
C     ==================================================================

      LOOP3: DO I3B = 1,IBSAVE  ! TOTAL NO. OF BLOCKS
         IIICNT = 1
 
         WRITE(93,*) ' '
         WRITE(93,*) ' block no. = ',I3B
CCC      WRITE(93,*) '    iiicnt = ',IIICNT
         WRITE(93,*) '  npc(i3b) = ',NPC(I3B)

         LOOP3n1: DO III = 1,NO ! WHERE NO = 361, MAX NO. RECORDS IN
                                ! BLOCK
            VSX(1:NS,JCELL(III,I3B),IROW(III,I3B),I3B)=VS2(1:NS,III,I3B)
            DSX(1:NS,JCELL(III,I3B),IROW(III,I3B),I3B)=DS2(1:NS,III,I3B)
            RSX(1:NS,JCELL(III,I3B),IROW(III,I3B),I3B)=RS2(1:NS,III,I3B)

            IBCX(JCELL(III,I3B),IROW(III,I3B),I3B)   = IBC(I3B)
            NPCX(JCELL(III,I3B),IROW(III,I3B),I3B)   = NPC(I3B)
            ICONFX(JCELL(III,I3B),IROW(III,I3B),I3B) = ICONF(I3B)
            IROWX(JCELL(III,I3B),IROW(III,I3B),I3B)  = IROW(III,I3B)
            JCELLX(JCELL(III,I3B),IROW(III,I3B),I3B) = JCELL(III,I3B)
            PCLTX(JCELL(III,I3B),IROW(III,I3B),I3B)  = PCLT(III,I3B)
            PCLNX(JCELL(III,I3B),IROW(III,I3B),I3B)  = PCLN(III,I3B)
            VEX(JCELL(III,I3B),IROW(III,I3B),I3B)    = VE(III,I3B)
            DEX(JCELL(III,I3B),IROW(III,I3B),I3B)    = DE(III,I3B)
            VMX(JCELL(III,I3B),IROW(III,I3B),I3B)    = VM(III,I3B)
            DMX(JCELL(III,I3B),IROW(III,I3B),I3B)    = DM(III,I3B)
            PCTRKX(JCELL(III,I3B),IROW(III,I3B),I3B) = PCTRK(III,I3B)
            BAX(JCELL(III,I3B),IROW(III,I3B),I3B)    = BA(0,III,I3B)
            NS4X(JCELL(III,I3B),IROW(III,I3B),I3B)   = NS4(III,I3B)
            IBETX(JCELL(III,I3B),IROW(III,I3B),I3B)  = IBET(III,I3B)
            IBHMSX(JCELL(III,I3B),IROW(III,I3B),I3B) = IHMS(III,I3B)
            IBYMDX(JCELL(III,I3B),IROW(III,I3B),I3B) = IYMD(III,I3B)

            IIICNT = IIICNT +1
  
C   CHECK FOR MAX RECORDS
            IF (IIICNT .GT. NPC(I3B)) EXIT LOOP3n1

         ENDDO LOOP3n1
      ENDDO LOOP3

C     SETTING UP CONTIGUOUS BLOCKS OF ARRAYS FOR SLICE
C     ================================================

C IF ICONF(IBSC) =0 THEN 1ST BLOCK OF CONTIGUOUS BLOCK SET, IBEGIN(II)
C IF ICONF(IBSC) =1 THEN PART OF CONTIGUOUS BLOCK SET, LAST = ILAST(II)
C IF ICONF(IBSC) =0 THEN NEXT BLOCK OF CONTIGUOUS BLOCK SET,IBEGIN(II+1)
C IF ICONF(IBSC) =1 THEN PART OF CONTIGUOUS BLOCK SET, ETC., ILAST(II+1)

C     IBC(IBSC) = BLOCK ID

C     IBSAVE = TOTAL NO. OF BLOCKS
C     ============================

      II = 0

      DO JJ = 1,IBSAVE
         IF(ICONF(JJ) .EQ. 0) THEN
            II = II + 1
            IBEGIN(II) = IBC(JJ)
            ILAST(II) = IBC(JJ)
            NROW(II) = NC ! NC = 19
         ELSE
            ILAST(II) = IBC(JJ)
            NROW(II) = NROW(II) + NC
         ENDIF
      ENDDO
  
      IISAVE = II

      WRITE(93,*) ' '
      WRITE(93,*) '     iisave = ',IISAVE

C     PREPARE DATA FOR SLICE
C     ======================

C     KOUNT = DATA COUNTER FOR QC'D DATA
C     ==================================

      KOUNT = 1

      DO IBS = 1,IISAVE
         III1 = IBEGIN(IBS)
         III2 = ILAST(IBS)
         IROSAV = NROW(IBS)

         WRITE(93,*) ' '
         WRITE(93,*) '   iii1 = ',III1
         WRITE(93,*) '   iii2 = ',III2
         WRITE(93,*) ' irosav = ',IROSAV

         NSOL2 = 0
         JJJ = 0

         DO III = III1, III2
            DO IJK = 1, NC
               JJJ = JJJ + 1 ! COUNTING ALL ROWS FROM III1 TO III2
    
C              IF (IJK .GT. 18) IJK = 0  ! LIMIT ROWS TO 19 PER BLOCK
      
                  !  1:NC  CELL ID
               VS3(1:4,1:NC,JJJ) = VSX(1:4,1:NC,IJK,III)
               DS3(1:4,1:NC,JJJ) = DSX(1:4,1:NC,IJK,III)
               RS3(1:4,1:NC,JJJ) = RSX(1:4,1:NC,IJK,III)
               DF(1:NC,JJJ)      = DFX(1:NC,IJK,III)
               IPCD(1:NC,JJJ)    = IPCDX(1:NC,IJK,III)
               IBCY(1:NC,JJJ)    = IBCX(1:NC,IJK,III)
               NPCY(1:NC,JJJ)    = NPCX(1:NC,IJK,III)
               ICONFY(1:NC,JJJ)  = ICONFX(1:NC,IJK,III)
               IROWY(1:NC,JJJ)   = IROWX(1:NC,IJK,III)
               JCELLY(1:NC,JJJ)  = JCELLX(1:NC,IJK,III)
               PCLTY(1:NC,JJJ)   = PCLTX(1:NC,IJK,III)
               PCLNY(1:NC,JJJ)   = PCLNX(1:NC,IJK,III)
               VEY(1:NC,JJJ)     = VEX(1:NC,IJK,III)
               DEY(1:NC,JJJ)     = DEX(1:NC,IJK,III)
               VMY(1:NC,JJJ)     = VMX(1:NC,IJK,III)
               DMY(1:NC,JJJ)     = DMX(1:NC,IJK,III)
               PCTRKY(1:NC,JJJ)  = PCTRKX(1:NC,IJK,III)
               BAY(1:NC,JJJ)     = BAX(1:NC,IJK,III)
               NS4Y(1:NC,JJJ)    = NS4X(1:NC,IJK,III)
               IBETY(1:NC,JJJ)   = IBETX(1:NC,IJK,III)
               IBHMSY(1:NC,JJJ)  = IBHMSX(1:NC,IJK,III)
               IBYMDY(1:NC,JJJ)  = IBYMDX(1:NC,IJK,III)

            ENDDO
         ENDDO    ! eND OF CONTIGUOUS SET OF DATA FROM IBEGIN TO ILAST

         WRITE(93,*) '    jjj = ',JJJ


C     $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
C            SLICE SLICE SLICE SLICE SLICE SLICE SLICE SLICE
C     $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

         CALL SLICE(IROSAV,VS3,DS3,RS3,IPCD,DF)

C     $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
C            SLICE SLICE SLICE SLICE SLICE SLICE SLICE SLICE
C     $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

C     WRITING OUT FILE WITH AMBIGUITY REMOVAL USING SLICE MODAL FILTER
C     FOR CONTIGUOUS SET OF DATA FROM IBEGIN TO ILAST
C     ================================================================
 
         DO JJJN = 1,IROSAV
            DO IJKN = 1,19
               IF(NS4Y(IJKN,JJJN).GT.0.AND.IBCY(IJKN,JJJN).NE.0) THEN
                  IYR            = IBYMDY(IJKN,JJJN)/10000 
                  RYEAR(KOUNT)   = FLOAT(IYR)
                  IMONT          = (IBYMDY(IJKN,JJJN) - IYR*10000)
                  IMO            = IMONT/100
                  RMONTH(KOUNT)  = FLOAT(IMO)
                  IDA            = (IMONT - IMO*100)
                  RDAY(KOUNT)    = FLOAT(IDA)
                  IHO            = IBHMSY(IJKN,JJJN)/10000
                  RHOUR(KOUNT)   = FLOAT(IHO)
                  IMINUT         = (IBHMSY(IJKN,JJJN) -IHO*10000)
                  IMIN           = IMINUT/100
                  RMINUTE(KOUNT) = FLOAT(IMIN)
                  ISEC           = (IMINUT- IMIN*100)
                  RSECOND(KOUNT) = FLOAT(ISEC)
                  LAT_Y(KOUNT)   = PCLTY(IJKN,JJJN)
                  LON_X(KOUNT)   = PCLNY(IJKN,JJJN)
                  E_SPEED(KOUNT) = VS3(1,IJKN,JJJN)
                  E_DIR(KOUNT)   = DS3(1,IJKN,JJJN)
                  ESA_SP(KOUNT)  = VEY(IJKN,JJJN)
                  ESA_DR(KOUNT)  = DEY(IJKN,JJJN)
                  IF (KOUNT.LE.10) THEN
                     WRITE(6,*) ' '
                     WRITE(6,*) 'FOR RECORD NUMBER ',KOUNT,':'
                     WRITE(6,*) 'year ........... ',RYEAR(KOUNT)
                     WRITE(6,*) 'month .......... ',RMONTH(KOUNT)
                     WRITE(6,*) 'day ............ ',RDAY(KOUNT)
                     WRITE(6,*) 'hour ........... ',RHOUR(KOUNT)
                     WRITE(6,*) 'minute ......... ',RMINUTE(KOUNT)
                     WRITE(6,*) 'second ......... ',RSECOND(KOUNT)
                     WRITE(6,*) 'latitude ....... ',LAT_Y(KOUNT)
                     WRITE(6,*) 'longitude ...... ',LON_X(KOUNT)
                     WRITE(6,*) 'speed .......... ',E_SPEED(KOUNT)
                     WRITE(6,*) 'direction ...... ',E_DIR(KOUNT)
                     WRITE(6,*) 'Esa speed ...... ',ESA_SP(KOUNT)
                     WRITE(6,*) 'Esa direction .. ',ESA_DR(KOUNT)
                     WRITE(6,*) ' '
                  ENDIF
                  KOUNT = KOUNT + 1
               ENDIF
            ENDDO
         ENDDO

         WRITE(93,*) ' '
         WRITE(93,*) '  no. of records after SLICE = ',KOUNT
         WRITE(93,*) ' '

      ENDDO     ! RETURN TO GET NEXT SET OF CONTIGUOUS BLOCKS

C  ENCODE THE SCATTEROMETER DATA IN NCEP BUFR USING BUFRLIB ROUTINES
C  -----------------------------------------------------------------

      CALL DATELEN(10)

      IRECL = 0
      ISUBL = 0
      ISUBT = 0
      IUNITI = 30
      IUNITP = 60
      IUNITT = 20
      SUBSET = 'NC012008'

C  GET THE CENTER & DUMP DATE FROM INPUT ORIGINAL BUFR DATA DUMP FILE
C  ------------------------------------------------------------------

      CALL DUMPBF(IUNITI,ICDATE,IDDATE)
      WRITE(6,*) ' '
      WRITE(6,*) 'From Original ERS Bufr Data Dump File in Unit 30 ',
     $ '(ERSWND):'
      WRITE(6,*) '     - Center date (ICDATE) = ',ICDATE
      WRITE(6,*) '     - Dump date   (IDDATE) = ',IDDATE
      WRITE(6,*) 'Will transfer these to output ERS BUFR file in Unit',
     $ ' 60 (ERSCAT)'
      WRITE(6,*) ' '
      IF(ICDATE(1).LE.0)  THEN

C  IF CENTER DATE COULD NOT BE READ FROM FIRST DUMMY MESSAGE, STOP 61
C  ------------------------------------------------------------------

         WRITE(6,*) 'DUMPBF ERROR - CENTER DATE COULD NOT BE READ ',
     $    'FROM INPUT ERS DATA DUMP FILE -- STOP 61'
         CALL W3TAGE('WAVE_DATASORT')
         CALL ERREXIT(61)
      END IF
      IF(IDDATE(1).LE.0)  THEN

C  IF DUMP DATE COULD NOT BE READ FROM SECOND DUMMY MESSAGE, STOP 62
C  -----------------------------------------------------------------

         WRITE(6,*) 'DUMPBF ERROR - DUMP DATE COULD NOT BE READ ',
     $    'FROM INPUT ERS DATA DUMP FILE -- STOP 62'
         CALL W3TAGE('WAVE_DATASORT')
         CALL ERREXIT(62)
      END IF

      IDATBF =ICDATE(1)*1000000 +ICDATE(2)*10000 +ICDATE(3)*100 +
     &        ICDATE(4)
      IDATDM =IDDATE(1)*1000000 +IDDATE(2)*10000 +IDDATE(3)*100 +
     &        IDDATE(4)

C  OPEN OUTPUT BUFR FILE WHICH WILL CONTAIN Q.C.'d ERS WIND DATA
C  -------------------------------------------------------------

      CALL OPENBF(IUNITP,'OUT',IUNITT)
      WRITE(6,101) IUNITP,IUNITT
  101 FORMAT(/8X,'===> BUFR DATA SET IN UNIT',I3,' SUCCESSFULLY OPENED',
     $ ' FOR OUTPUT; BUFR MNEMONIC TABLES A,B,D IN UNIT',I3/13X,'READ ',
     $ 'IN AND ENCODED INTO BEGINNING MESSAGES OF OUTPUT DATA SET'/)

C  TRANSFER CENTER & DUMP DATE FROM INPUT BUFR FILE TO OUTPUT BUFR FILE
C  --------------------------------------------------------------------

      CALL OPENMG(IUNITP,SUBSET,IDATBF)
      CALL MINIMG(IUNITP,ICDATE(5))
      CALL OPENMG(IUNITP,SUBSET,IDATDM)
      CALL MINIMG(IUNITP,IDDATE(5))
      CALL CLOSMG(IUNITP)

      CALL OPENMG(IUNITP,SUBSET,IDATBF)

c  LOOP THROUGH ALL REPORTS AND ENCODE INTO NCEP BUFR FILE
c  -------------------------------------------------------

      DO ICNT = 1, KOUNT

         RDATA(1)  = RYEAR(ICNT)
         RDATA(2)  = RMONTH(ICNT)
         RDATA(3)  = RDAY(ICNT)
         RDATA(4)  = RHOUR(ICNT)
         RDATA(5)  = RMINUTE(ICNT)
         RDATA(6)  = RSECOND(ICNT)
         RDATA(7)  = LAT_Y(ICNT)
         RDATA(8)  = LON_X(ICNT)
         RDATA(9)  = E_SPEED(ICNT)
         RDATA(10) = E_DIR(ICNT)
         RDATA_8(1:10) = RDATA(1:10)
         KOUNT1 = MIN(ICNT,9999999)
         WRITE(STNID(1:7),'(I7.7)')  KOUNT1
         STNID(8:8) = 'E'
         RDATA_8(11) = RPID_8
         CALL UFBINT(IUNITP,RDATA_8,11,1,IRET,
     $    'YEAR MNTH DAYS HOUR MINU SECO CLAT CLON WS10 WD10 RPID')

C  WRITE THE ENCODED SUBSET (REPORT) INTO THE OUTPUT BUFR MESSAGE
C  --------------------------------------------------------------

         CALL WRITSB(IUNITP)
         CALL UFBCNT(IUNITP,IREC,ISUB)
         IF(IREC.GT.IRECL)  THEN
            ISUBT = ISUBT + ISUBL
            WRITE(6,1254) IREC-1,ISUBL,ISUBT
 1254 FORMAT(/' --- THIS REPORT OPENS NEW BUFR MSG: LAST MSG WAS NO.',
     $ I10,' (DATA) WITH',I5,' RPTS (TOTAL NO. RPTS WRITTEN=',I7,')'/)
         END IF
         ISUBL = ISUB
         IRECL = IREC
ccc      IF (ICNT.LE.10) THEN
ccc         DO IXNT = 1,10
ccc            WRITE(6,*) 'IXNT = ',IXNT
ccc            WRITE(6,*) 'RDATA(IXNT) = ',RDATA(IXNT)
ccc         ENDDO
ccc         WRITE(6,*) 'IXNT = 11'
ccc         WRITE(6,*) 'RDATA(11) = ',STNID
ccc      END IF

      ENDDO

C  CLOSE NCEP BUFR DATA SET
C  ------------------------

      CALL UFBCNT(IUNITP,IREC,ISUB)
      ISUBT = ISUBT + ISUB
      WRITE(6,1253) IREC,ISUB,ISUBT
 1253 FORMAT(/' --- WROTE BUFR DATA MSG NO.',I10,' WITH',I5,' REPORTS ',
     $ '(TOTAL NO. REPORTS WRITTEN =',I7,')'/)
      CALL CLOSBF(IUNITP)
      WRITE(6,102) IUNITP
  102 FORMAT(/5X,'===> BUFR DATA SET IN UNIT',I3,' SUCCESSFULLY ',
     $ 'CLOSED'/)
      WRITE(6,1267) KOUNT
 1267 FORMAT(' >>>  TOTAL NUMBER OF REPROCESSED ERS WIND REPORTS ',
     $ 'WRITTEN ...     ',I6,'  <<<'//)

      CALL W3TAGE('WAVE_DATASORT')
      STOP

C-----------------------------------------------------------------------
 8600 WRITE(6,*) 'SOME KIND OF ERROR READING INPUT FILE IN UNIT 12'
      WRITE(6,*) 'EXECUTION HALTS - STOP 33'
      CALL W3TAGE('WAVE_DATASORT')
      CALL ERREXIT(33)
C-----------------------------------------------------------------------

      END

C#######################################################################
C#######################################################################
C#######################################################################

      SUBROUTINE AVANG ( A, N, AV, SD )

C ROUTINE          AVANG  SUBROUTINE  G0401  FORT77  ANGLES.FOR
C
C PURPOSE          CALCULATE MEAN & S.DEV OF A SET OF ANGLES, IN DEG.
C
C ARGUMENTS        A  (ENTRY/EXIT)  R4  ARRAY OF ANGLES IN DEG.
C                  N  (ENTRY)       I4  NUMBER OF ANGLES IN ARRAY.
C                  AV (EXIT)        R4  AVERAGE ANGLE (0-360DEG)
C                  SD (EXIT)        R4  STD. DEV. OF ANGLES (DEG)
C
C INTRINSICS       ABS, AMOD, FLOAT, SIGN
C
C DESCRIPTION      GIVEN A SET OF ANGLES (0-360 OR +/-180 DEG),
C                  CALCULATES THEIR MEAN AND STANDARD DEVIATION.
C                  TAKES CARE OF ANGLES SPANNING 0 OR 180 DEG. 
C                  VALUES IN ARRAY 'A' MAY BE ALTERED TO BETWEEN
C                  0 & 360 DEG; RETURNED AVERAGE ANGLE WILL BE IN
C                  THE RANGE 0-360 DEG.
C
C VERSION          1.02  JAN 92   D OFFILER
C
C CHANGES          01  ADD STANDARD DEVIATION CALC.  D.O.  SEP 84
C                  02  A) CHANGE FROM FUNCTION TO SUBROUTINE: PASS
C                         AV & SD VIA ARGUMENT LIST.
C                      B) CODE ANG180/ANG360 IN-LINE.
C                      C) COPE WITH CALLS WHERE N=0.  D.O.  JAN 92
C

      INTEGER N
      REAL    A(*), AV, SD

C MAKE SURE ALL ANGLES BETWEEN 0 & 360 DEG.

      DO I = 1, N
         A(I) = AMOD ( A(I), 360.0 )
         IF ( A(I) .LT. 0.0 ) A(I) = A(I) + 360.0
      ENDDO

C ALTER ANGLES TO SAME SIGN.

      IF ( N .GT. 1 ) THEN
         NM1 = N - 1
         DO I = 1, NM1
            DIF = A(I) - A(I+1)
            IF ( ABS ( DIF ) .GT. 180.0 )
     *               A(I+1) = A(I+1) + SIGN (360.0 , DIF )
         ENDDO
      ENDIF

C CALC AVERAGE & S.D.

      AV = 0.0
      IF ( N .GE. 1 ) THEN
         DO I = 1, N
           AV = AV + A(I)
         ENDDO
         AV = AV / FLOAT ( N )
         IF ( AV .LT.   0.0 ) AV = AV + 360.0
         IF ( AV .GE. 360.0 ) AV = AV - 360.0
      ENDIF

      SD = 0.0
      IF ( N .GT. 1 ) THEN
         DO I = 1, N
            S = A(I) - AV
            IF ( S .GT. 180.0 ) S = 360.0 - S
            SD = SD + S * S
         ENDDO
         SD = SQRT ( SD / FLOAT ( N - 1 ) )
      ENDIF

      END

C#######################################################################
C#######################################################################
C#######################################################################

      SUBROUTINE CLCSEC (IHMS,ISS)

      ih = ihms / 10000
      im = (ihms - ih*10000)/100
      is = ihms - ih*10000 - im*100
      iss = ih*3600 + im*60 + is
      return
      end

C#######################################################################
C#######################################################################
C#######################################################################

      FUNCTION DMODAL ( ANG, CON, NA, DSD )

C ROUTINE          DMODAL  FUNCTION  A0002  VAXFORT  SLICE.FOR
C
C PURPOSE          FINDS LOCAL BEST ESTIMATE WIND DIRECTION
C
C PROJECT          EDIPVS
C
C ARGUMENTS        ANG   (ENTRY)  R4  ARRAY OF WIND DIRECTIONS
C                  CON   (ENTRY)  R4  ARRAY OF AMB.REM.CONFIDENCES
C                  NA    (ENTRY)  I4  NO. OF ITEMS IN ANG & CON
C                  DSD    (EXIT)  R4  S.DEV. OF DIRECTIONS IN SECTORS
C                                    CLOSEST TO DEBEST.
C                  DMODAL (FUNC)  R4  RETURNED BEST ESTIMATE DIRN.
C                                    (-999. IF NONE)
C                             
C SUBPROGRAMS      AVANG
C
C INTRINSICS       INT, MOD
C
C DESCRIPTION      FINDS MODAL LOCAL WIND DIRECTION, DMODEL, FROM NA 
C                  INPUT ANGLES, ANG.
C                  THE ANGLES ARE BINNED INTO SECTORS AND THE
C                  SECTION WITH THE HIGHEST FREQUENCY CHOSEN AS
C                  THE MOST LIKELY GENERAL DIRECTION. IF THIS
C                  SECTION (PLUS ITS 2 NEIGHBOURING ONES) CONTAIN
C                  ENOUGH ELEMENTS, THE LOCAL RANK 1'S SHOW
C                  CONSISTENCY - THE BEST ESTIMATE IS THE AVERAGE
C                  DIRECTION IN THEM. IF NOT, THE LOCAL RANK 1'S
C                  ARE INCONSISTENT, AND A VALUE OF -999. IS RETURNED.
C                  THE AMBIGUITY REMOVAL CONFIDENCE UPDATE FIGURE IS
C                  CALCULATED ACCORDING TO THE DEGREE OF AGREEMENT.
C
C VERSION          1.03  DECEMBER 1992  ORIG: D. OFFILER  NOV 1989
C
C CHANGES          01  AVANG NOW A SUBROUTINE.   D.O.  10 JAN 92
C                  02  RETURN DSD IN ARG. LIST.  D.O.  25 NOV 92
C                  03  RENAMED FRON `DBEST'.     D.O.   8 DEC 92
C

      IMPLICIT NONE

      INTEGER NS, LOLIM
      REAL    SECTOR
      PARAMETER ( NS = 8 , SECTOR = 45.0, LOLIM = 4 )

C ARGUMENT LIST PARAMETERS

      INTEGER NA
      REAL    ANG(*), CON(*), DSD, DMODAL

C LOCAL PARAMETERS

      INTEGER IA, IC, IS, ISM1, ISP1
      INTEGER MA, MS, MFR, MSM1, MSP1
      INTEGER IFR1(NS), IFR2(NS), ISUMC, IWGHT(10)
      INTEGER ICONF, ISECT
      REAL    ANGLE, CONF
              
      DATA IWGHT / 1,1,1,1,1,2,2,2,3,5 /

C FUNCTION REFERENCES FOR (1) SECTOR ID, GIVEN ANGLE (1-8)
C                         (2) CONFIDENCE INTERVAL    (1-10)

      ISECT ( ANGLE ) = INT ( ANGLE / SECTOR ) + 1

      ICONF ( CONF ) = MIN ( MAX ( INT ( CONF*10.0 ) + 1, 1 ), 10 )

C IF TOO FEW NEIGHBOURING CELLS, NO SIGNIFICANT LOCAL DIRECTION
C IS DERIVABLE.

      DMODAL = -999.0
      DSD    = 0.0
      IF ( NA .LT. LOLIM ) RETURN

C INITIALISE SECTOR FREQUENCIES      

      IFR1(1:NS) = 0

C COUNT NO. OF ANGLES IN EACH SECTOR, WEIGHTED BY THEIR CONFIDENCE
C FACTORS. (ACTUAL WEIGHT FROM LOOK UP TABLE)

      ISUMC = 0
      DO IA = 1, NA
         IS = ISECT ( ANG(IA) )
         IC = ICONF ( CON(IA) )
         IFR1(IS) = IFR1(IS) + IWGHT(IC)
         ISUMC = ISUMC + IWGHT(IC)
      ENDDO

C WEIGHTED SUM OF NEIGHBOURING SECTOR FREQUENCIES.
C FIND SECTOR WITH MOST WEIGHT, PLUS THE 2 NEIGHBOURING SECTORS.
 
      MFR = 0
      DO IS = 1, NS
         ISM1 = MOD ( IS+NS-2, NS ) + 1
         ISP1 = MOD ( IS     , NS ) + 1
         IFR2(IS) = IFR1(ISM1) + 2 * IFR1(IS) + IFR1(ISP1)
         IF ( IFR2(IS) .GT. MFR ) THEN
            MFR = IFR2(IS)
            MS  = IS
         ENDIF
      ENDDO

      MSM1 = MOD ( MS+NS-2, NS ) + 1
      MSP1 = MOD ( MS     , NS ) + 1
      MFR = IFR2(MSM1) + IFR2(MS) + IFR2(MSP1)

C FIND AVERAGE ANGLE IN THE 3 CHOSEN SECTORS IF MORE THAN 'LIM' 
C ANGLES ARE IN THEM (I.E. THERE IS SOME CONSISTENCY IN LOCAL 
C DIRECTIONS). THIS WILL BE THE BEST ESTIMATE LOCAL DIRECTION. IF 
C THE NUMBER OF ANGLES IS LESS THAN THE LIMIT, THERE IS NO CONSISTENCY.
C CONFIDENCE UPDATE FACTOR IS RELATED TO DEGREE OF CONSISTENCY.

      IF ( MFR .GT. ISUMC*2 ) THEN
         MA = 0
         DO IA = 1, NA
            IS = ISECT ( ANG(IA) )
            IF ( IS .EQ. MSM1 .OR. IS .EQ. MS .OR.
     $           IS .EQ. MSP1 ) THEN
               MA = MA + 1
               ANG(MA) = ANG(IA)
            ENDIF
         ENDDO

         IF ( MA .GT. 1 ) THEN
            CALL AVANG ( ANG, MA, DMODAL, DSD )
            DSD = DSD * 3.0 * FLOAT ( NA ) / FLOAT ( MA )
            DSD = MIN ( MAX ( DSD, 20.0 ), 90.0 )
         ENDIF
      ENDIF

      END

C#######################################################################
C#######################################################################
C#######################################################################

      SUBROUTINE EXTFIT ( CLAT, CLON, PCD, VSOL, DSOL, RSOL, 
     $                    VBG, DBG )

C ROUTINE          EXTFIT  SUBROUTINE  A0003  VAXFORT  EXTFIT.FOR
C
C PURPOSE          FIT SCATT. RETRIEVALS TO EXTERNAL BACKGROUND FIELD
C
C PROJECT          EDIPVS
C
C ARGUMENTS        CLAT (ENTRY)       R4  CELL LATITUDE  (DEG)
C                  CLON (ENTRY)       R4  CELL LONGITUDE (DEG)
C                  PCD  (ENTRY)       I2  PRODUCT CONFIDENCE FLAGS
C                  VSOL (ENTRY/EXIT)  R4  4 SPEEDS (M/S)
C                  DSOL (ENTRY/EXIT)  R4  4 DIRECTIONS (DEG)
C                  RSOL (ENTRY/EXIT)  R4  4 RELATIVE PROBABILITIES (0-1)
C                  VBG  (ENTRY/EXIT)  R4  BACKGROUND SPEED (M/S)
C                  DBG  (ENTRY/EXIT)  R4  BACKGROUND DIRECTION (DEG)
C                  QBG  (ENTRY/EXIT)  R4  BACKGROUND QUALITY (0-1)
C
C SUBPROGRAMS      RKONBGD, WBKGND
C
C INTRINSICS       ABS, BTEST, IBCLR, MAX
C
C DESCRIPTION      FITS SCATT SOLUTIONS TO AN EXTERNAL BACKGROUND
C                  WIND FIELD BY SELECTING THE MOST PROBABLE SOLUTION 
C                  TO THE B/G WIND (WHICH IS ITERPOLATED FROM MODEL FIELD
C                  TO THE CELL LOCATION, OR IF NO FIELD AVAILABLE,
C                  THE ENTRY B/G IF VALID), AND (IF NECCESSARY) 
C                  RE-RANKING THE SOLUTION SET. THE B/G WIND USED 
C                  & ITS QUALITY INDEX IS RETURNED, THE AMBIGUITY 
C                  REMOVAL CONFIDENCE VALUE MODIFIED AND THE PRODUCT 
C                  CONFIDENCE 'B/G NOT USED' FLAG CLEARED. IF NO B/G 
C                  (EITHER FROM MODEL FIELD OR PASSED ON ENTRY), THEN 
C                  THE B/G SPEED, DIRECTION AND AND QUALITY ARE RETURNED
C                  AS ZERO VALUES.
C
C ALGORITHM        THE PREFERRED B/G WIND IS INTERPOLATED FROM A WIND
C                  FIELD; IF NONE IS AVAILABLE, THE B/G WIND PASSED
C                  IN THE ARGUMENT LIST IS USED. IF THIS, TOO, IS NOT 
C                  VALID, THEN NOTHING IS DONE TO THE SCATT. WINDS.
C                  IF A B/G WIND IS AVAILABLE FROM EITHER SOURCE,
C                  IT IS CHECKED AGAINST THE CURRENT RANK 1 SCATT.
C                  WIND BY CALCULATING THE PROBABILITY OF THE EACH 
C                  SOLUTION FITTING THE B/G SPEED AND DIRECTION.
C                  VALID SOLUTIONS ARE THEN RE-RANKED IN DECREASING 
C                  ORDER OF PROBABILITY.
C
C VERSION          1.05  NOVEMBER 1992  ORIG: D.OFFILER  SEP 89
C
C CHANGES          01  MODIFY ARC UPDATE.          D.O.  21 AUG 91
C                  02  A) USE A VALID ENTRY B/G WIND IF NO FILE
C                         B/G AVAILABLE. 
C                      B) CODE ANG180 IN-LINE.     D.O.  23 JAN 92
C                  03  ADD B/G QUALITY PARAMETER.  D.O.  28 JAN 92
C                  04  A) ATTEMPT TO EXTRACT & RETURN B/G WIND EVEN IF 
C                         RETRIEVAL WAS NOT MADE.
C                      B) ARC VALUE CALCULATED BY S/R BGDARC.
C                                                  D.O.  15 OCT 92
C                  05  A) SELECT SOLUTIONS BY PROBABILITIES RATHER THAN
C                      'CLOSEST TO B/G DIRECTION'  (DONE IN S/R RKONBGD)
C                      B) ARC NOW AS RSOL(1).      D.O.  27 NOV 92
C
c Recieved by P.WOICESHYN for use & modification, JPL/NOAA FEB 22, 1993.
c
c

      IMPLICIT NONE

      INTEGER NS
      PARAMETER ( NS = 4 )

C ARGUMENT LIST PARAMETERS

      INTEGER PCD
      REAL    CLAT, CLON, VSOL(NS), DSOL(NS), RSOL(NS)
      REAL    VBG, DBG, QBG

C LOCAL PARAMETERS

      INTEGER IRK1, NVS
      REAL    VBF, DBF, QBF

C CONVERT LAT/LON TO B/G GRID COORDS, & INTERPOLATE (U,V) FROM NEAREST
C GRID POINTS. IF THERE IS A VALID WIND FROM BACKGROUND FIELD, USE IT,
C ELSE USE DEFAULT BACKGROUND. 

c      CALL WBKGND ( CLAT, CLON, VBF, DBF, QBF )
c      IF ( QBF .GE. 0.005 ) THEN
c         VBG = VBF
c         DBG = DBF
c         QBG = QBF
c      ENDIF

C PCD BIT 12 SET (NO RETIEVAL MADE FOR THIS CELL), OR B/G IS NOT VALID, 
C AMBIGUITY REMOVAL NOT REQUIRED, ELSE RE-RANK ON BACKGROUND, AND
C CLEAR FLAG IN PCD BIT 10 TO INDICATE USE OF B/G VECTOR 

c      IF ( .NOT. BTEST ( PCD, 11 ) .AND. QBG .GE. 0.01 ) THEN
         CALL RKONBGD ( VSOL, DSOL, RSOL, VBG, DBG, NVS, IRK1 )
c         IF ( NVS .GT. 0 ) PCD = IBCLR ( PCD,  9 )
c      ENDIF
            
      END

C#######################################################################
C#######################################################################
C#######################################################################

      SUBROUTINE FIT3 ( X, Y, C0, C1, C2 )

C ROUTINE          FIT3  SUBROUTINE  U0031  FORT77  FIT3.FOR
C
C PURPOSE          FITS A QUADRATIC CURVE TO THREE POINTS
C
C ARGUMENTS        X   (ENTRY)  3R4  ARRAY OF 3 X (INEPENDENT) COORDS
C                  Y   (ENTRY)  3R4  ARRAY OF 3 Y (DEPENDENT) COORDS
C                  C0  (EXIT)    R4  CONSTANT COEFFICIENT
C                  C1  (EXIT)    R4  FIRST-ORDER COEFFICIENT
C                  C2  (EXIT)    R4  SECOND-ORDER COEFFICIENT
C
C INTRINSICS       ABS
C
C DESCRIPTION      GIVEN THREE COORDINATE PAIRS (X1,Y1), (X2,Y2)
C                  AND (X3,Y3), FIT3 WILL FIT AN EXACT QUADRATIC
C                  CURVE PASSING THROUGH THESE 3 POINTS, AND RETURN
C                  THE QUADRATIC CURVE COEFFICIENTS C0, C1 AND C2
C                  SUCH THAT:
C                     Y = C0 + C1 * X + C2 * X**2
C                  THE METHOD IS ONE OF SIMULTANEOUS EQUATIONS
C                  WITH SUBSTITUTION, FIRST TO SOLVE FOR C2,
C                  THEN C1 AND FINALLY C0. THE THREE 'X' VALUES
C                  MUST BE DISTINCT AND IN ASCENDING OR DESCENDING
C                  NUMERICAL ORDER.
C
C VERSION          1.01  OCTOBER 1992  ORIG: D. OFFILER  SEPT 89
C
C CHANGES          01  RE-ORDER COEFS IN ARGUMENT LIST.  D.O.  14 OCT 92
C
c Recieved by P.WOICESHYN for use & modification, JPL/NOAA FEB 19, 1993.
c
c

C ARGUMENT LIST PARAMETERS

      REAL C0, C1, C2, X(*), Y(*)

      DATA EPS / 1E-10 /

      X12  = X(1) - X(2)
      X13  = X(1) - X(3)
      X1S  = X(1) * X(1)
      X12S = X1S - X(2) * X(2)
      X13S = X1S - X(3) * X(3)

      A1 = X13 * ( Y(1) - Y(2) ) - X12 * ( Y(1) - Y(3) )
      A2 = X13 * X12S - X12 * X13S
      IF ( ABS ( A2 ) .GT. EPS ) THEN
         C2 = A1 / A2
      ELSE
         C2 = 0.0
      ENDIF

      IF ( ABS ( X13 ) .GT. EPS ) THEN
         C1 = ( Y(1) - Y(3) - C2 * X13S ) / X13
      ELSE
         C1 = 0.0
      ENDIF

      C0 = Y(1) - C2 * X1S - C1 * X(1)

      END

C#######################################################################
C#######################################################################
C#######################################################################

      FUNCTION PROB ( DIFF, SDEV )

C ROUTINE          PROB  FUNCTION  U0071  VAXFORT  PROB.FOR
C
C PURPOSE          CALCULATE PROBABILITY OF ERROR VS A BACKGROUND
C
C PROJECT          EDIPVS
C
C ARGUMENTS        DIFF  (ENTRY)  R4  OBSERVATION-BACKGROUND DIFFERENCE
C                  SDEV  (ENTRY)  R4  ESTIMATED SDANDARD DEVIATION IN
C                                     BACKGROUND ERRORS.
C                  PROB  (FUNCN)  R4  PROBABILITY DENSITY (0.0 - 1.0)
C
C INTRINSICS       EXP
C
C DESCRIPTION      CALCULATES THE PROBABILITY DENSITY OF A MEASUREMENT 
C                  DIFFERENCE FROM A BACKGROUND GIVEN THE LIKELY 
C                  STANDARD DEVIATION IN BACKGROUND ERRORS (ASSUMED 
C                  GAUSSIAN, WITH ZERO MEAN DIFFERENCE). PROBABILITY
C                  DENSITY IS SCALED TO GIVE UNITY FOR ZERO DIFFERENCE.
C                  EXAMPLES:
C                    DIFF = 0       -->  PROB = 1.000
C                    DIFF = SDEV    -->  PROB = 0.606
C                    DIFF = 2*SDEV  -->  PROB = 0.135
C                    DIFF = 3*SDEV  -->  PROB = 0.011
C
C ALGORITHM        PROB = EXP(-(DIFF/SDEV)**2/2)
C
C VERSION          1.00  NOVEMBER 1992  ORIG:  D. OFFILER  NOV 92
C
c Recieved by P.WOICESHYN for use & modification, JPL/NOAA FEB 19, 1993.
c
c

      IMPLICIT NONE

      REAL DIFF, SDEV, PROB, VAR

      PROB = EXP ( -0.5 * DIFF * DIFF / MAX ( SDEV * SDEV, 1E-10 ) )

      END

C#######################################################################
C#######################################################################
C#######################################################################

      FUNCTION QSPEED ( DG, S0, AI, BA )
C ROUTINE          QSPEED FUNCTION  M0004  VAXFORT  QSPEED.FOR
C
C PURPOSE          QUICK RETRIEVAL OF WIND SPEED.
C
C PROJECT          EDIPVS
C
C ARGUMENTS        DG     (ENTRY)  R4  FIRST GUESS WIND DIRECTION (DEG)
C                  S0     (ENTRY)  R4  3 MEASURED SIGMA-0'S (DB)
C                  AI     (ENTRY)  R4  3 BEAM INCIDENCE ANGLES (DEG)
C                  BA     (ENTRY)  R4  3 BEAM AZIMUTH ANGLES (DEG)
C                  QSPEED (FUNC)   R4  QUICK-LOOK WIND SPEED (M/S)
C
C COMMON           /CMODEL/
C                  MODEL  (WRITE)  C10  MODEL ID
C
C FILES            UNIT(12)  FILE(CMOD_QSLUT)  SPEED COEFFICIENTS (I/P)
C
C INTRINSICS       INT, MAX, MIN
C
C DESCRIPTION      PERFORMS A QUICK-LOOK RETRIEVAL OF WIND SPEED
C                  GIVEN A FIRST-GUESS WIND DIRECTION.
C                  RETRIEVAL ERRORS WILL BE DOMINATED BY THE EFFECTIVE
C                  NOISE IN THE SIGMA-0 MEASUREMENTS; NOISLESS S-0
C                  LEAD TO ERRORS (S.D.) OF GENERALLY <0.1M/S, BUT
C                  DEPEND ON THE C-BAND MODEL.
C                  SPEED COEFFICIENTS FILE IS SPECIFIED VIA THE LOGICAL
C                  NAME 'CMOD_QSLUT'.
C
C ALGORITHM        USES A PRE-COMPUTED SET OF QUADRATIC COEFFICIENTS
C                  THAT GIVE LOG(SPEED) OR SQRT(SPEED) AS A FUNCTION 
C                  OF BACKSCATTER IN DB, TABULATED WITH BEAM INCIDENCE 
C                  ANGLE & WIND DIRECTION RELATIVE TO THE BEAM AZIMUTH.
C                  THE TABULATED SET OF COEFFICIENTS ARE INTERPOLATED
C                  TO GIVEN INCIDENCE ANGLE AND WIND DIRECTION, AND
C                  APPLIED TO THE MEASURED SIGMA-0 GIVE LOG(SPEED)
C                  OR SQRT(SPEED) FOR EACH BEAM AND HENCE MEAN SPEED
C                  FROM ALL USABLE BEAMS - MISSING BEAMS ARE ALLOWED
C                  FOR. 
C
C REFERENCE        COEFFS. GENERATED BY PROGRAM LUTGEN (M1000) AND
C                  TESTED BY SPETEST (M3000).
C
C VERSION          1.04  NOVEMBER 1992  ORIG: D.OFFILER  APR 89
C
C CHANGES          01  COEFFICIENTS FILE VIA LOGICAL NAME.  D.O.
C                  02  LIMIT QSPEED VALUE TO 100M/S         D.O.  JAN 92
C                  03  (A) MODIFIED LUT FILE (15-60DEG INC.) AND
C                          COEFFS FOR TWO SPEED (S0) RANGES.
C                      (B) IF MODEL IS CMOD5, USE SQRT(V) RELATION,
C                          ELSE LOG(V).
C                      (C) INTERPOLATE COEFFS.
C                      (D) NO LONGER USE KP AS SCALING.     D.O.  OCT 92
C                  04  USE S0 VALUE TO REJECT MISSING BEAMS INSTEAD OF
C                      LOGICAL FLAG ARRAY.                  D.O.  NOV 92
C
c Recieved by P.WOICESHYN for use & modification, JPL/NOAA FEB 19, 1993.
c
c

      IMPLICIT NONE

      INTEGER IPCHAN, NB, NA, ND, NV
      REAL    FD, FA, DD, DA, S0MIN
      PARAMETER ( IPCHAN = 42, NB = 3, ND = 37, NA = 46, NV = 2 )  
      PARAMETER ( FD = 0.0, FA = 15.0 )
      PARAMETER ( DD = 5.0, DA =  1.0 )
      PARAMETER ( S0MIN = -50.0 )

C ARGUMENT LIST PARAMETERS

      REAL     QSPEED, DG, S0(NB), AI(NB), BA(NB)

C LOCAL PARAMETERS

      CHARACTER*10 MODEL, LUTFIL
      INTEGER IA, IB, ID, IV
      REAL    B0, B1, B2
      REAL    C0(NV,ND,NA), C1(NV,ND,NA), C2(NV,ND,NA), SC(ND,NA)
      REAL    A, A0, D, D0, EN, R1, R2, VV, W, X, Y, Z
      LOGICAL FIRST

      COMMON / CMODEL / MODEL

      DATA LUTFIL / 'CMOD_QSLUT' /
      DATA FIRST  / .TRUE. /
                                                              
C READ SPEED COEFFICIENTS LOOK-UP TABLE FOR FIRST ENTRY.

      save
	
      IF ( FIRST ) THEN
c         OPEN  ( IPCHAN, FILE=LUTFIL, FORM='UNFORMATTED',
c     $           STATUS='OLD' )
         READ  ( IPCHAN ) MODEL, C0, C1, C2, SC
c         CLOSE ( IPCHAN )
         FIRST = .FALSE.
        ENDIF

C FIND NEAREST TABULATED COEFFS & EVALUATE SPEED FROM EACH ACTIVE BEAM
C & CALCULATE MEAN
                     
      VV = 0.0
      EN = 0.0
      DO IB = 1, NB
         IF ( S0(IB) .GT. S0MIN ) THEN
            EN = EN + 1.0

C D IS RELATIVE WIND DIRECTION TO BEAM (0-180DEG ONLY)

            D = BA(IB) - DG
   10       CONTINUE
            IF ( D .LT. 0.0 ) D = -D                     
               IF ( D .LE. 180.0 ) GOTO 20
               D = D - 360.0
               GOTO 10
   20       CONTINUE
            A = AI(IB)

C INTERPOLATE COEFFICIENTS IN REL.DIR. & INC.ANG., & SELECT APPROPRIATE
C  SET OF COEFFS WITH NOMINAL WIND SPEED RANGE.

            D0 = ( D - FD ) / DD + 1.0
            A0 = ( A - FA ) / DA + 1.0

            ID = MIN ( MAX ( INT ( D0 ), 1 ), ND-1 )
            IA = MIN ( MAX ( INT ( A0 ), 1 ), NA-1 )
            IF ( S0(IB) .LT. SC(ID,IA) ) THEN
               IV = 1
            ELSE
               IV = 2
            ENDIF

            R1 = D0 - ID
            R2 = A0 - IA

            W = C0(IV,ID,IA)
            X = C0(IV,ID,IA+1)   - W
            Y = C0(IV,ID+1,IA)   - W
            Z = C0(IV,ID+1,IA+1) - W - X - Y
            B0 = W + X * R2 + Y * R1 + Z * R1 * R2

            W = C1(IV,ID,IA)
            X = C1(IV,ID,IA+1)   - W
            Y = C1(IV,ID+1,IA)   - W
            Z = C1(IV,ID+1,IA+1) - W - X - Y
            B1 = W + X * R2 + Y * R1 + Z * R1 * R2
 
            W = C2(IV,ID,IA)
            X = C2(IV,ID,IA+1)   - W
            Y = C2(IV,ID+1,IA)   - W
            Z = C2(IV,ID+1,IA+1) - W - X - Y
            B2 = W + X * R2 + Y * R1 + Z * R1 * R2

            VV = VV +
     $           B0 + B1 * S0(IB) + B2 * S0(IB) * S0(IB)
         ENDIF
      ENDDO
                                                          
C ESTIMATE SPEED OVER ALL USABLE BEAMS
                
      IF ( EN .GT. 0.5 ) THEN
         VV = VV / EN
         IF ( MODEL(5:5) .EQ. '5' ) THEN
            QSPEED = MIN ( VV * VV, 100.0 )
         ELSE
            QSPEED = 10.0 ** MIN ( VV, 2.0 )
         ENDIF
      ELSE
         QSPEED = 0.0
      ENDIF

      END

C#######################################################################
C#######################################################################
C#######################################################################

      SUBROUTINE RANK ( VSOL, DSOL, RSOL, NVS, IRK1 )

C ROUTINE          RANK  SUBROUTINE  R0003  FORT77  RANK.FOR
C                  
C PURPOSE          RANK SOLUTIONS IN ORDER OF PROBABILITY 
C                                                   
C PROJECT          EDIPVS
C
C ARGUMENTS        VSOL  (ENTRY/EXIT)  R4  4 WIND SPEEDS (M/S)
C                  DSOL  (ENTRY/EXIT)  R4  4 WIND DIRECTIONS (DEG)
C                  RSOL  (ENTRY/EXIT)  R4  4 PROBABILITIES (0.0-1.0)
C                  NVS   (EXIT)        I4  NO. OF VALID SOLUTIONS (0-4)
C                  IRK1  (EXIT)        I4  PREVIOUS RANK OF NEW RANK 1
C                                          (1-4)
C
C DESCRIPTION      GIVEN THE 'RAW' AMBIGUOUS SOLUTIONS FROM THE WIND 
C                  RETRIEVAL FITTING PROCESS, THIS ROUTINE RANKS THEM 
C                  IN ORDER OF DECREASING PROBABILITY (BY A BUBBLE-SORT)
C                  ON EXIT, THE MOST PROBABLE SOLUTION (RANK 1) IS FIRST
C                  IN THE ARRAYS. ON EXIT, THE PROBABILITIES ARE
C                  RELATIVE FOR EACH SOLUTION (I.E. SUM TO UNITY) UNLESS
C                  ON ENTRY ALL RSOL VALUES ARE ZERO. ALSO RETURNED IS
C                  THE NUMBER OF VALIS SOLUTIONS (SCALED RSOL>0.001).
C
C VERSION          1.04  NOVEMBER 1992  ORIG: D. OFFILER  SEP 89
C
C CHANGES          01  A) INCREASE THESHOLD FOR LARGE, BUT VALID 
C                         RESIDUALS (BIGADD 1,000 --> 100,000).  
C                      B) COUNT & RETURN NO. OF VALID SOLUTIONS.
C                      C) FUNCTION ANG180 CODED IN-LINE.
C                                                     D.O.   7 JAN 92
C                  02  LOSING PRECISION WITH LARGE BIGADD AND VERY
C                      SMALL RESIDUALS; MAKE BIGADD DYNAMIC - JUST 
C                      BIGGER THAN ABSOLUTE VALUE OF BIGGEST RESIDUAL.  
C                                                     D.O.  16 SEP 92
C                  03  RAISE DTOL FROM 10 TO 20 DEG.  D.O.  15 OCT 92
C                  04  A) RANK BY DECREASING PROBABILITY, RATHER THAN
C                         BY INCREASING RESIDUAL. 
C                      B) DON'T REJECT DUPLICATES (WHICH SHOULD NO 
C                         LONGER BE GENERATED BY S/R WINRET.
C                                                     D.O.  26 NOV 92
C

      IMPLICIT NONE

      INTEGER NB, NS
      REAL    EPS, RMIN
      PARAMETER ( NB   = 3, NS = 4 ) ! NB = no. beams/NS = max no. solns
      PARAMETER ( EPS  = 1E-7 )      ! an arbitrary small value
      PARAMETER ( RMIN = 0.001 )     ! minimum prob. to be a valid soln.
                                     ! (after scaling)

C ARGUMENT LIST PARAMETERS

      INTEGER NVS, IRK1
      REAL    VSOL(NS), DSOL(NS), RSOL(NS)

C LOCAL PARAMETERS
   
      INTEGER I, J
      REAL    PTOT, RR, VV, DD

C SCALE PROBABILITES TO SUM TO UNITY & COUNT NO. OF VALID SOLUTIONS

      PTOT = 0.0
      DO I = 1, NS
         PTOT = PTOT + RSOL(I)
      ENDDO

      NVS = 0
      IF ( PTOT .GT. EPS ) THEN
         DO I = 1, NS
            RSOL(I) = RSOL(I) / PTOT
            IF ( RSOL(I) .GT. RMIN ) NVS = NVS + 1
         
         ENDDO
      ENDIF

C RANK SOLUTIONS IN DECREASING ORDER OF (RELATIVE) PROBABILITY BY BUBBLE
C  SORT

      IRK1 = 1
      DO I = 1, NS-1
         DO J = I+1, NS
            IF ( RSOL(J) .GT. RSOL(I) ) THEN
               VV = VSOL(J)
               DD = DSOL(J)
               RR = RSOL(J)

               VSOL(J) = VSOL(I)
               DSOL(J) = DSOL(I)
               RSOL(J) = RSOL(I)

               VSOL(I) = VV
               DSOL(I) = DD
               RSOL(I) = RR

               IF ( I .EQ. 1 ) IRK1 = J
            ENDIF
         ENDDO
      ENDDO

      END

C#######################################################################
C#######################################################################
C#######################################################################

      FUNCTION RESID ( VV, DD, S0, AI, BA )

C ROUTINE          RESID  FUNCTION  R0002  VAXFORT  RESID.FOR
C
C PURPOSE          CALCULATES RESIDUAL SUM OF SQUARES
C
C PROJECT          EDIPVS
C
C ARGUMENTS        VV     (ENTRY)  R4  WIND SPEED (M/S)
C                  DG     (ENTRY)  R4  WIND DIRECTION W.R.T. NORTH (DEG)
C                  S0     (ENTRY)  R4  3 MEASURED SIGMA-0 VALUES (DB)
C                  AI     (ENTRY)  R4  3 BEAM INCIDENCE ANGLES (DEG)
C                  BA     (ENTRY)  R4  3 BEAM AZIMUTH ANGLES WRT NTH
C                                      (DEG)
C                  RESID  (FUNC)   R4  RESIDUAL SUM OF SQUARES
C             
C SUBPROGRAMS      TSIGDB
C
C DESCRIPTION      CALCULATES THE SUM OVER THE 3 BEAMS OF THE
C                  SQUARES OF THE RESIDUAL DIFFERENCE BETWEEN
C                  THE MEASURED BACKSCATTER AND THEORETICAL
C                  C-BAND MODEL VALUES (BOTH IN DB MEASURE),
C                  GIVEN THE CELL GEOMETRY.
C
C VERSION          1.02  NOVBEMBER  1992  ORIG: D. OFFILER  SEP 89
C
C CHANGES          01  RESIDUAL NO LONGER NORMALISED; USE DB
C                      INSTEAD OF LINEAR MEASURE; RE-ORDER REMAINING
C                      ARGUMENT LIST PARAMETERS.     D.O.   7 OCT 92
C                  02  MISSING BEAMS TAKEN FROM S0 VALUE INSTEAD OF
C                      SEPARATE LOGICAL FLAG ARRAY.  D.O.  26 NOV 92
C
c Recieved by P.WOICESHYN for use & modification, JPL/NOAA FEB 19, 1993.
c
c

      IMPLICIT NONE

      INTEGER NB 
      REAL   S0MIN
      PARAMETER ( NB = 3, S0MIN = -50.0 )

      REAL    RESID, VV, DD, S0(NB), AI(NB), BA(NB)

      INTEGER IB
      REAL    R, TSIGDB

      RESID = 0.0
      DO IB = 1, NB
         IF ( S0(IB) .GT. S0MIN ) THEN
            R     = S0(IB) - TSIGDB ( VV, BA(IB)-DD, AI(IB) )
            RESID = RESID + R * R
         ENDIF
      ENDDO

      END

C#######################################################################
C#######################################################################
C#######################################################################

      SUBROUTINE RETPROB ( NVS, AIM, SPD, PRB )

C ROUTINE          RETPROB  SUBROUTINE  R0005  FORT77  RETPROB.FOR
C
C PURPOSE          RETRIEVAL AMBIGUITY REMOVAL CONFIDENCE VALUE
C
C PROJECT          EDIPVS
C
C ARGUMENTS        NVS   (ENTRY)  I4  NO. OF VALID SOLUTIONS (2-4)
C                  AIM   (ENTRY)  R4  MID BEAM INCIDENCE ANGLE
C                  (15-50DEG)
C                  SPD   (ENTRY)  R4  WIND SPEED (0-50M/S)
C                  PRB   (EXIT)   R4  CALC. PROBABILITY VALUE (0.0-1.0)
C
C DESCRIPTION      CALCULATES AN `AMBIGUITY REMOVAL CONFIDENCE' VALUE
C                  AFTER BASIC RETRIEVAL. PRB IS A FUNCTION OF THE
C                  NUMBER OF VALID SOLUTIONS RETRIEVED, THE MID-BEAM 
C                  INCIDENCE ANGLE & THE RETRIEVED (RANK 1) WIND SPEED. 
C                  THIS VERSION TUNED TO CMOD4.
C
C REFERENCES       COEFFICIENTS FOUND & VALIDATED USING PROGRAM
C                  ARCVAL (VXXXX).
C
C VERSION          1.00  NOVEMBER 1992  ORIG: D. OFFILER  NOV 92
C
c Recieved by P.WOICESHYN for use & modification, JPL/NOAA FEB 19, 1993.
c
c

      IMPLICIT NONE

C ARGUMENT LIST PARAMETERS

      INTEGER NVS
      REAL    AIM, SPD, PRB

C LOCAL PARAMETERS

      INTEGER IA, IS, IV
      REAL    PRBA(7,4), PRBV(6,4)

C PRBA = MEAN RK1 PERFORMANCE BY INC.ANG (15-20,20-25...), AND BY NO. OF
C        SOLUTIONS, FOR ALL SPEEDS
C PRBV = MEAN RK1 PERFORMANCE BY SPD (0-4,4-8...) AND BY NO. OF
C        SOLUTIONS, FOR ALL INC.ANG.

      DATA PRBA  / 7*0.50,
     $             0.53, 0.59, 0.62, 0.61, 0.63, 0.64, 0.62,
     $             0.51, 0.48, 0.54, 0.51, 0.53, 0.54, 0.54,
     $             0.49, 0.45, 0.48, 0.48, 0.54, 0.55, 0.56 /
      DATA PRBV  / 6*0.50,
     $             0.52, 0.60, 0.65, 0.73, 0.80, 0.90,
     $             0.49, 0.48, 0.60, 0.78, 0.90, 0.90,
     $             0.48, 0.48, 0.53, 0.49, 0.90, 0.90 /

      IS = MIN ( MAX ( NVS, 1 ), 4 )

      IA = INT ( AIM - 15.0 ) / 5 + 1
      IA = MIN ( MAX ( IA, 1 ), 7 )

      IV = INT ( SPD ) / 4 + 1
      IV = MIN ( MAX ( IV, 1 ), 6 )

      PRB = ( PRBA(IA,IS) + PRBV(IV,IS) ) * 0.5

      END

C#######################################################################
C#######################################################################
C#######################################################################

      SUBROUTINE RKONBGD ( VSOL, DSOL, RSOL, VBG, DBG, NVS, IRK1 )

C ROUTINE          RKONBGD  SUBROUTINE  R0012  VAXFORT  RANK.FOR
C
C PURPOSE          RE-RANK SOLUTIONS ON BACKGROUND WIND
C
C PROJECT          EDIPVS
C
C ARGUMENTS        VSOL  (ENT/EX)  R4  4 WIND SPEEDS (M/S)
C                  DSOL  (ENT/EX)  R4  4 WIND DIRECTIONS (DEG.T)
C                  RSOL  (ENT/EX)  R4  4 RELATIVE PROBABILITIES (0-1)
C                  VBG   (ENTRY)   R4  BACKGROUND WIND SPEED (M/S)
C                  DBG   (ENTRY)   R4  BACKGROUND WIND DIRECTION (DEG.T)
C                  NVS   (EXIT)    I4  NO. OF VALID SOLUTIONS (0-4)
C                  IRK1  (EXIT)    I4  PREVIOUS RANK OF NEW RANK 1 (1-4)
C
C SUBPROGRAMS      PROB, RANK
C
C INTRINSICS       ABS, MAX, MIN, SQRT
C
C DESCRIPTION      CALCULATES LIKELY ERRORS (S.DEV) IN WIND SPEED AND
C                  DIRECTION FOR BOTH BACKGROUND AND SCATT. WINDS,
C                  THEN PROBABILITY OF EACH SCATT SOLUTION FITTING THE
C                  GIVEN BACKGROUND. THESE PROBABILITIES ARE USED TO
C                  MODIFY THE ORIGINAL ONES FROM THE RETRIEVAL STAGE,
C                  AND SOLUTIONS ARE RE-RANKED ON THE NEW PROBS.
C
C REFERENCES       1) PARRETT,CA. BACKGROUND ERRORS FOR THE QUALITY 
C                  CONTROL AND ASSIMILATION OF ATMOSPHERIC OBSERVATIONS
C                  IN THE UNIFIED MODEL - THE SITUATION IN JULY 1992.
C                  S-DIVISION TECH.REP.22, AUG 92.
C                  2) BELL,S. NOTE ON 'ARC'. PERSONAL COMM. 23 OCT 91.
C                  
C VERSION          1.00  NOVEMBER 1992  ORIG: D.OFFILER  NOV 92
C

      IMPLICIT NONE

      INTEGER NS
      REAL    EPS
      PARAMETER ( NS  =   4  ) ! max. no. solutions
      PARAMETER ( EPS = 1E-7 ) ! an arbitrary small number

C ARGUMENT LIST PARAMETERS

      INTEGER NVS, IRK1
      REAL    VSOL(NS), DSOL(NS), RSOL(NS), VBG, DBG

C LOCAL PARAMETER

      INTEGER IS
      REAL    VBGSD, DBGSD, VSLSD, DSLSD, VSDEV, DSDEV
      REAL    DDIF, VDIF
      REAL    PROB

C LIKELY ERROR IN B/G SPEEDS & DIRCN. AS FN SPEED (SEE REFS)

      VBGSD =   2.0 + VBG * 0.1
      DBGSD = 200.0 / MIN ( VBG+1.0, 10.0 )

C LIKELY ERROR IN SCATT SPEEDS & DIRCN.

      VSLSD = MAX  (  2.0, VSOL(1) * 0.1 )
      DSLSD = MAX  ( 20.0, DBGSD   * 0.5 )

C CALCULATE PROBABILITY OF EACH SOLUTION BEING 'CORRECT' GIVEN
C LIKELY ERRORS IN BOTH SOURCES OF WIND; MODIFY ORIGINAL 'RETRIEVAL'
C PROBABILITIES ACCORDINGLY.

      VSDEV = SQRT ( VBGSD * VBGSD + VSLSD * VSLSD ) 
      DSDEV = SQRT ( DBGSD * DBGSD + DSLSD * DSLSD ) 

      DO IS = 1, NS
         IF ( RSOL(IS) .GT. EPS ) THEN
            VDIF = ABS ( VBG - VSOL(IS) )
            DDIF = ABS ( DBG - DSOL(IS) )
            IF ( DDIF .GT. 180.0 ) DDIF = 360.0 - DDIF
            RSOL(IS) = RSOL(IS) 
     $               * PROB ( VDIF, VSDEV )
     $               * PROB ( DDIF, DSDEV )
         ENDIF
      ENDDO

C RANK ON NEW (SCALED RELATIVE) PROBABILITIES

      CALL RANK ( VSOL, DSOL, RSOL, NVS, IRK1 )

      END

C#######################################################################
C#######################################################################
C#######################################################################

      SUBROUTINE RKONLFD ( VSOL, DSOL, RSOL, DLOCAL, DLSD, RKONBG,
     $                     NVS, IRK1 )

C ROUTINE          RKONLFD  SUBROUTINE  R0013  VAXFORT  RANK.FOR
C
C PURPOSE          RANK ON LOCAL FIELD DIRECTION
C
C PROJECT          EDIPVS
C
C ARGUMENTS        VSOL   (ENT/EX)  R4  4 SPEEDS (M/S)
C                  DSOL   (ENT/EX)  R4  4 DIRECTIONS (DEG.T)
C                  RSOL   (ENT/EX)  R4  4 RELATIVE PROBABILITIES (0-1)
C                  DLOCAL  (ENTRY)  R4  LOCAL FIELD DIRECTION (DEG.T)
C                  DLSD    (ENTRY)  R4  ESTIMATE OF S.DEV IN DLOCAL
C                                       (DEG)
C                  RKONBG  (ENTRY)  L4  .T. IF CELL RANKED ON B/G WINDS
C                  NVS      (EXIT)  I4  NO. OF VALID SOLUTIONS (0-4)
C                  IRK1     (EXIT)  I4  PREVIOUS RANK OF NEW RANK 1
C                                       (1-4)
C
C SUBPROGRAMS      PROB, RANK
C
C INTRINSICS       ABS
C
C DESCRIPTION      MODIFIES SOLUTION PROBABILITIES ACCORDING TO THEIR
C                  FIT TO GIVEN LOCAL FIELD DIRECTION. IF CELL HAS BEEN
C                  ALREADY BEEN RANKED USING BACKROUND WINDS, THE 
C                  RELATIVE PROBABILITY OF RK1 ON ENTRY IS LIKELY TO
C                  BE TOO HIGH TO CAUSE A NEW RANK TO BE CHOSEN, SO
C                  IN THIS CASE, THE ORIGINAL PROB. VALUES ARE ADJUSTED
C                  TO BE LESS POLARISED. SOLUTIONS WITH VERY LOW
C                  RELATIVE PROBS ARE IGNORED.
C
C VERSION          1.00  NOVEMBER 1992  ORIG: D.OFFILER  NOV 92
C

      IMPLICIT NONE

      INTEGER NS, IRK1
      REAL    RMIN
      PARAMETER ( NS   =     4 ) ! max. no. of solutions
      PARAMETER ( RMIN = 0.001 ) ! solution prob. >0.001 to be valid

C ARGUMENT LIST PARAMETERS

      INTEGER NVS
      REAL    VSOL(NS), DSOL(NS), RSOL(NS), DLOCAL, DLSD
      LOGICAL RKONBG
 
C LOCAL PARAMETERS

      INTEGER IS
      REAL    DDIF, RADJ(NS), DSSD, DSDEV
      REAL    PROB

      DATA RADJ / 0.70, 0.15, 0.10, 0.05 /
      DATA DSSD / 20.0 /

      DSDEV = SQRT ( DSSD * DSSD + DLSD * DLSD )

      DO IS = 1, NS
CCC         IF ( RKONBG .AND. RSOL(IS) .GT. RMIN ) RSOL(IS) = RADJ(IS)

         IF ( RSOL(IS) .GT. RMIN ) THEN
            DDIF = ABS ( DSOL(IS) - DLOCAL )
            IF ( DDIF .GT. 180.0 ) DDIF = 360.0 - DDIF
            RSOL(IS) = RSOL(IS) * PROB ( DDIF, DSDEV )
         ENDIF
      ENDDO

      CALL RANK ( VSOL, DSOL, RSOL, NVS, IRK1 )

      END
*---------------------------------------------------------------------
*   RANK.FOR   --   RANKING ROUTINES
*---------------------------------------------------------------------
*  CALL RKONRES ( VSOL, DSOL, RSOL, S0, AI, BA, KP, NVS, IRK1 )
*
*  CALL RKONBGD ( VSOL, DSOL, RSOL, VBG, DBG, NVS, IRK1 )
*
*  CALL RKONLFD ( VSOL, DSOL, RSOL, DLOCAL, DSD, RKONBG, NVS, IRK1 )
*
*  CALL RANK    ( VSOL, DSOL, RSOL, NVS, IRK1 )
*---------------------------------------------------------------------

C#######################################################################
C#######################################################################
C#######################################################################

      SUBROUTINE RKONRES ( VSOL, DSOL, RSOL, S0, AI, BA, KP, NVS, IRK1 )

C ROUTINE          RKONRES  SUBROUTINE  R0011  VAXFORT  RANK.FOR
C
C PURPOSE          RANK SOLUTIONS ON RESIDUAL PROBABILITIES
C
C PROJECT          EDIPVS
C
C ARGUMENTS        VSOL  (ENT/EX)  R4  4 SPEEDS (M/S)
C                  DSOL  (ENT/EX)  R4  4 DIRECTIONS (DEG.T)
C                  RSOL  (EXIT)    R4  4 RELATIVE PROBABILITIES (0-1)
C                  S0    (ENTRY)   R4  3 SIGMA-0 VALUES (DB)
C                  AI    (ENTRY)   R4  3 BEAM INCIDENCE ANGLES (DEG)
C                  BA    (ENTRY)   R4  3 BEAM AZIMUTH ANGLES (DEG.T)
C                  KP    (ENTRY)   R4  3 BEAM KP VALUES (PERCENT)
C                  NVS   (EXIT)    I4  NO. OF VALID SOLUTIONS (0-4)
C                  IRK1  (EXIT)    I4  PREVIOUS RANK OF NEW RANK 1 (1-4)
C
C SUBPROGRAMS      PROB, RANK, RESID, RETPROB
C
C INTRINSICS       ALOG10, MAX, SQRT
C
C DESCRIPTION      CALCULATES RESIDUAL FROM MODEL EACH SOLUTION,
C                  AND PROBABILITY FROM (RMS) RESIDUAL, GIVEN
C                  AN ESTIMATE OF THE S.DEV IN S0'S. THEN RANKS
C                  IN DECENDING ORDER OF (RELATIVE) PROBABILITIES.
C                  RANK 1 PROBABILITY REPLACED BY LIKELY (VALIDATED)
C                  VALUE & RKS 2-4 ADJUSTED TO KEEP RELATIVE VALUES
C                  AND SO THAT SUM OF ALL RANKS REMAINS UNITY.
C
C VERSION          1.00  NOVBEMBER 1992  ORIG: D.OFFILER  NOV 92
C
c Recieved by P.WOICESHYN for use & modification, JPL/NOAA FEB 19, 1993.
c
c

      IMPLICIT NONE

      INTEGER NB, NS
      REAL    EPS, S0MIN, CALVAR, FITVAR, KPSC, KPNVAR, VMAX, RMIN
      PARAMETER ( NB = 3, NS = 4 )! NB = no. beams/NS = max no. solns
      PARAMETER ( EPS    =  1E-7 ) ! an arbitrary small value
      PARAMETER ( CALVAR =  0.04 ) ! beam calibration error (0.2dB rms)
      PARAMETER ( FITVAR =  0.04 ) ! c-band model fit error (0.2dB rms)
      PARAMETER ( KPSC   =   3.0 ) ! Kp scaling for `geophysical' noise
      PARAMETER ( KPNVAR =  0.04 ) ! nominal Kp error (approx 5%)
      PARAMETER ( S0MIN  = -50.0 ) ! beam considered missing if s0<-50dB
      PARAMETER ( VMAX   =  50.8 ) ! max wind speed for a valid solution
      PARAMETER ( RMIN   = 0.001 ) ! minimum prob. for valid retrieval
                                   ! (before scaling) - equivalent to an 
                                   ! rms residual of ~2.2db w/ total s0 
                                   ! s.dev=0.64db (Kp~5%)
C ARGUMENT LIST PARAMETERS

      INTEGER NVS, IRK1
      REAL    VSOL(NS), DSOL(NS), RSOL(NS), S0ERR
      REAL    S0(NB), AI(NB), BA(NB), KP(NB)

C LOCAL PARAMETERS

      INTEGER IB, IS
      REAL    KPSD, RES, RMAX, RTOT, R1, RR
      REAL    PROB, RESID

C ESTIMATE S.DEV OF ERROR IN S0'S 

      S0ERR = 0.0
      DO IB = 1, NB
         IF ( S0(IB) .GT. S0MIN ) THEN
            KPSD  = 10.0 * ALOG10 ( 1.0 + KPSC*KP(IB)*0.01 )
            S0ERR = S0ERR + KPSD * KPSD
         ELSE
            S0ERR = S0ERR + KPNVAR
         ENDIF
      ENDDO
      S0ERR = SQRT ( ( S0ERR / NB ) + CALVAR + FITVAR )

C CALC. PROBABILITIES FOR EACH SOLUTION'S RMS RESIDUAL, GIVEN S0 ERROR

      RMAX = 0.0
      DO IS = 1, NS
         IF ( VSOL(IS) .LE. VMAX ) THEN
            RES      = RESID ( VSOL(IS), DSOL(IS), S0, AI, BA )
            RSOL(IS) = PROB  ( SQRT ( RES / NB ), S0ERR )
            RMAX     = MAX   ( RMAX, RSOL(IS) )
         ELSE
            RSOL(IS) = 0.0
         ENDIF
      ENDDO

C RANK SOLUTIONS IN ORDER OF SCALED (RELATIVE) PROBABILITIES

      CALL RANK ( VSOL, DSOL, RSOL, NVS, IRK1 )

C UNFORTUNATELY, THE RANK 1 RELATIVE PROBABILITY (RSOL(1)) IS NOT A 
C GOOD PREDICTOR OF WHETHER THIS SOLUTION IS CORRECT OR NOT.
C WE THEREFORE CALCULATE A (PRE-VALIDATED) SUBSTITUTE VALUE,
C BASED ON NO. OF VALID SOLUTIONS, WIND SPEED AND INCIDENCE ANGLE. 
C SCALE OTHER RSOLS TO MAINTAIN RELATIVE SIZE AND UNITY SUM

      IF ( RMAX .GE. RMIN .AND. NVS .GT. 0 ) THEN
         CALL RETPROB ( NVS, AI(2), VSOL(1), R1 )
         RR      = R1 / RSOL(1)
         RSOL(1) = R1

         IF ( NVS .GT. 1 ) THEN
            RTOT    = 0.0
            DO IS = 2, NS
               RSOL(IS) = RSOL(IS) * RR
               RTOT     = RTOT + RSOL(IS)
            ENDDO
         
            NVS = 1
            R1  = ( 1.0 - R1 ) / RTOT
            IF ( RTOT .GT. EPS ) THEN
               DO IS = 2, NS
                  RSOL(IS) = MIN ( RSOL(IS) * R1, RSOL(IS-1) * 0.99 )
                  IF ( RSOL(IS) .GT. RMIN ) NVS = NVS + 1
               ENDDO
            ENDIF
         ENDIF

C RETRIEVAL REJECTED IF HIGHEST PROBABILTY 'RMAX' TOOLOW 
C (IE POOR RESIDUAL FIT TO C-BAND MODEL)

      ELSE
         NVS = 0
      ENDIF

      END

C#######################################################################
C#######################################################################
C#######################################################################

      SUBROUTINE SLICE ( NR, VS, DS, RS, PCD, DF )

C ROUTINE          SLICE  SUBROUTINE  A0001  VAX/MSFORT  SLICE.FOR
C
C PURPOSE          OBJECTIVE 2-D WIND DIRECTION AMBIGUITY FILTER
C
C TITLE            SEQUENTIAL LOCAL ITERATIVE CONSISTENCY ESTIMATOR
C
C PROJECT          EDIPVS
C
C ARGUMENTS        NR   (ENTRY)       I4  NO. OF ROWS TO PROCESS (1-MR)
C                  VS   (ENTRY/EXIT)  R4  4X19XMR WNS SPEEDS
C                  DS   (ENTRY/EXIT)  R4  4X19XMR WNS DIRECTIONS (0-360
C                                         DEG)
C                  RS   (ENTRY/EXIT)  R4  4X19XMR PROBABILITIES (0-1)
C                  PCD  (ENTRY/EXIT)  I2  19XMR PRODUCT CONFIDENCE FLAGS
C                  DF   (EXIT)        R4  19XMR LOCAL AVG DIRECTIONS
C                                         (0-360 DEG) WHERE MR=19*6
C
C SUBPROGRAMS      DMODAL
C                  RKONLFD
C
C INTRINSICS       ABS, BTEST, IBCLR, MAX, MIN, MOD
C
C DESCRIPTION      SETS AMBIGUOUS WIND FIELD CLOSEST TO LOCALLY
C                  FITTED RANK1 SPEED & DIRECTION.
C                  THE INPUT DATA IS AN ARRAY OF CELLS WITH UP TO 4
C                  AMBIGUOUS SOLUTIONS PER CELL, TOGETHER WITH THEIR
C                  RELATIVE PROBABILITIES, PRODUCT CONFIDENCE FLAGS 
C                  AND AMBIGUITY REMOVAL CONFIDENCE FIGURE. 
C                  THE SOLUTIONS ARE ASSUMED TO HAVE ALREADY BEEN RANKED
C                  IN DECREASING ORDER OF PROBABILITY BASED ON RESIDUALS
C                  AND/OR USING A BACKGROUND WIND FIELD. 
C
C VERSION          1.03  NOVEMBER 1992  ORIG: D. OFFILER  NOV 1989
C
C CHANGES          01  CHANGE TO PCD FLAG BIT POSITIONS.  D.O.    DEC 90
C                  02  FIX SIZE OF PASSED ARRAYS (MR).    D.O.    JAN 90
C                  03  USE SOLUTION PROBABILITIES, RATHER THAN
C                      RESIDUALS TO SELECT CANDIDATE SOLUTIONS.
C                                                         D.O. 27 NOV 92
C
c Recieved by P.WOICESHYN for use & modification, JPL/NOAA FEB 22, 1993.
c
c
                   
      IMPLICIT NONE

      INTEGER MAXBUF, NS, NC, MR, IBLIM, NA, ITLIM, NCHLIM
      REAL    RMIN
      PARAMETER ( NS =  4 )     ! no. of solutions
      PARAMETER ( NC = 19 )     ! no. rows per product (& cells per row)
C     PARAMETER ( MAXBUF = 6 ) ! max no. of products ! changed - PMW -
      PARAMETER ( MAXBUF = 250 )    ! max no. of products
      PARAMETER ( MR = NC*MAXBUF )! max. no. of rows
      PARAMETER ( IBLIM  = 5 )    ! size of local area (5x5 cells)      
      PARAMETER ( NA = IBLIM*IBLIM ) ! max no. of cells in local area
      PARAMETER ( ITLIM  =    6 ) ! max. no. of iterations
      PARAMETER ( NCHLIM =   10 ) ! stop if <10 ranks chgd on any iterat
      PARAMETER ( RMIN   = 0.50 ) ! Rk1 prob. > 0.5 to be selected as
C                                   neighbour

C ARGUMENT LIST PARAMETERS

      INTEGER NR
      INTEGER PCD(NC,MR)
      REAL    VS(NS,NC,MR), DS(NS,NC,MR), RS(NS,NC,MR), DF(NC,MR)

C LOCAL PARAMETERS

      INTEGER I1, I2, IF, IL, IMAX, IMIN, ISTEP
      INTEGER J1, J2, JF, JL, JMAX, JMIN, JSTEP
      INTEGER IB, IS, IRK1, ITER, NANG, NCHA, NVS
      REAL    VSOL(NS), DSOL(NS), RSOL(NS), ANG(NA), CON(NA)
      REAL    DLOCAL, DDIF, DSD
      REAL    DMODAL
      LOGICAL RKONBG

C SWEEP ALONG & ACROSS SWATH IN ALTERNATE DIRECTIONS (STARTING FIRST
C  ROW, AT OUTER EDGE OF SWATH) UNTIL ONLY A SMALL NUMBER OF CHANGES
C  HAVE BEEN MADE OR MAX. NO. OF ITERATIONS REACHED.

      IB = IBLIM / 2

      LOOP1: DO ITER = 1, ITLIM
         NCHA = 0

         IF ( MOD ( ITER, 2 ) .EQ. 1 ) THEN
            JF = 1             
            JL = NR
            JSTEP = 1                     
         ELSE
            JF = NR                                
            JL = 1
            JSTEP = -1
         ENDIF

         LOOP1n1: DO J1 = JF, JL, JSTEP
            IF ( MOD ( J1+ITER, 2 ) .EQ. 0 ) THEN
               IF = NC
               IL = 1
               ISTEP = -1
            ELSE
               IF = 1
               IL = NC
               ISTEP = 1
            ENDIF

            LOOP1n2: DO I1 = IF, IL, ISTEP
                 
C SKIP CELLS WITH NO RETREIVAL

C              IF ( BTEST ( PCD(I1,J1), 11 ) ) CYCLE LOOP1n2

               IF ( ds(1,I1,J1) .gt. 500.0 ) CYCLE LOOP1n2

C COLLECT NEIGHBOURING RANK 1 WIND SPEEDS & DIRECTIONS IN A BOX 
C IB X IB CELLS, EXCLUDING:
C A) LOW RELATIVE PROBABILITY RK1 CELLS (E.G. NO RETRIEVAL, NOT FITTED 
C    TO B/G FIELD, ETC)
C B) THE CENTRE CELL (SINCE THAT'S THE ONE WE'RE COMPARING) 
C N.B. CLOSE TO THE EDGE OF THE SWATH THERE MAY BE A LIMITED NUMBER OF 
C NEIGHBOURS, OR NONE AT ALL IN SOME AREAS WITHOUT A B/G.

               NANG = 0
               IMIN = MAX ( I1 - IB,  1 )
               IMAX = MIN ( I1 + IB, NC )
               JMIN = MAX ( J1 - IB,  1 )
               JMAX = MIN ( J1 + IB, NR )

               DO J2 = JMIN, JMAX
                  DO I2 = IMIN, IMAX
                     IF ( RS(1,I2,J2) .GE. RMIN .AND.
     $                  ( I2 .NE. I1 .OR. J2 .NE. J1 ) ) THEN
                        NANG = NANG + 1
                        ANG(NANG) =   DS(1,I2,J2)
                        CON(NANG) =   RS(1,I2,J2)
                     ENDIF
                  ENDDO
               ENDDO

C FIND LOCAL BEST ESTIMATE WIND DIRECTION USING THESE NEIGHBOURS 

               DLOCAL = DMODAL ( ANG, CON, NANG, DSD )

C IF THE NEIGHBOURS CONFLICT (DLOCAL=-999) (OR THERE ARE NOT ENOUGH
C NEIGHBOURS), ABANDON THIS CELL FOR NOW.
C IF AGREEMENT, MODIFY PROBABILITY OF EACH SOLUTION FITTING 
C LOCAL BEST ESTIMATE DIRECTION, & RE-RANK.

               IF ( DLOCAL .GE. 0.0 ) THEN
                  VSOL(1:NS) = VS(1:NS,I1,J1)
                  DSOL(1:NS) = DS(1:NS,I1,J1) 
                  RSOL(1:NS) = RS(1:NS,I1,J1) 
                  IF ( BTEST ( PCD(I1,J1), 9 ) ) THEN
                     RKONBG = .FALSE.
                  ELSE
                     RKONBG = .TRUE.
                  ENDIF
                  CALL RKONLFD ( VSOL, DSOL, RSOL, DLOCAL, DSD,
     $                           RKONBG, NVS, IRK1 )

C SAVE (POSSIBLE) NEW ORDER OF SOLUTIONS, UPDATED PROBABILITIES &
C LOCAL WIND DIR. FLAG CELL AS 'SLICED'. COUNT NO. OF RANKS CHANGED.

                  IF ( IRK1 .GT. 1 ) THEN
                     VS(1:NS,I1,J1) = VSOL(1:NS) 
                     DS(1:NS,I1,J1) = DSOL(1:NS) 
                     RS(1:NS,I1,J1) = RSOL(1:NS) 
                     NCHA = NCHA + 1
                  ENDIF

                  DF(I1,J1)  = DLOCAL
                  PCD(I1,J1) = IBCLR ( PCD(I1,J1), 8 )
               ELSE
                  DF(I1,J1)  = 510.0
               ENDIF

            ENDDO LOOP1n2

         ENDDO LOOP1n1

         WRITE(6,'(/1X,A,I5,A,A,I2/)') '*** SLICE: ', NCHA,' ranks ',
     $    'changed on iteration ', ITER

C IF ONLY A FEW RANKS HAVE BEEN CHANGED, FINISH.        

         IF ( NCHA .LE. NCHLIM ) GOTO 500

      ENDDO LOOP1

C HERE ON LIMIT OF ITERATIONS OR NO. OF CHANGES

  500 CONTINUE

      END      

C#######################################################################
C#######################################################################
C#######################################################################

      SUBROUTINE SORTDT (IBSAVE,SIDATE,IDATE,INDEX)

c     SORTING SUBROUTINE
c     ==================

      PARAMETER ( n2block = 100)
      integer(8) idate(n2block),sidate
c
      if (ibsave.eq.1) then
         index = 1
         goto 2
      else
         do ib=1,ibsave-1
            if (idate(ib).gt.sidate) then
               index = ib
               goto 2
            endif
         enddo
         index = ibsave
      endif
 2    continue
c     print *,'in sortdt, ibsave,sidate,index=',ibsave,',',
c    1    sidate,',',index
      return
      end

C#######################################################################
C#######################################################################
C#######################################################################

      FUNCTION TSIGDB ( U, D, A )

C-----------------------------------------------------------------------
C   TSIG0.FOR   ---   TABULATED SIGMA0 AS A FUNCTION OF WIND SPEED,
C                     DIRECTION AND INCIDENCE ANGLE, FOR BACKSCATTER
C                     IN DB (TSIGDB) AND LINEAR (TSIGLN)
C-----------------------------------------------------------------------
C S0DB = TSIGDB ( U, D, A )
C
C S0LN = TSIGLN ( U, D, A )
C-----------------------------------------------------------------------
C ROUTINE          TSIGDB  FUNCTION  M0002  VAXFORT  TSIG0.FOR
C
C PURPOSE          INTERPOLATED TABLULAR SIGMA-0 (DB)
C
C PROJECT          EDIPVS
C
C ARGUMENTS        U      (ENTRY)  R4  WIND SPEED (M/S)
C                  D      (ENTRY)  R4  REALATIVE WIND DIRN. (DEG)
C                  A      (ENTRY)  R4  INCIDENCE ANGLE (DEG)
C                  TSIGDB  (FUNC)  R4  SIGMA-0 (DB)
C
C COMMON           /CMODEL/
C                  MODEL  (WRITE)  C10  MODEL ID
C
C FILES            UNIT(11)  FILE(CMOD_DBLUT)  SIGMA-0 L.U.T. (I/P)
C
C INTRINSICS       ABS, INT, MIN, SIGN
C
C RTL              EXIT
C
C DESCRIPTION      INTERPOLATES SIGMA-0 (IN DB MEASURE) FROM 3-D 
C                  LOOK-UP TABLE OF BACKSCATTER VS. WIND SPEED 
C                  (1-30  M/S, IN 1 M/S STEPS), WIND DIRECTION
C                  (0-180 DEG, IN 5 DEG STEPS) AND INCIDENCE ANGLE
C                  (15-60 DEG, IN 1 DEG STEPS). 
C                  THE FIRST CALL TO THE ROUTINE LOADS THE LUT FROM
C                  DISK; THE FILE IS SPECIFIED VIA THE LOGICAL NAME
C                  'CMOD_DBLUT'
C
C ALGORITHM        FROM GIVEN PARAMETERS, FINDS NEAREST TABULATED
C                  VALUES, AND DOES A TRI-LINEAR INTERPOLATION.
C                  THE INTERPOLATION IS CAST IN A FORM WHICH MINIMISES
C                  THE NUMBER OF FLOATING-POINT OPERATORS (IE + - * / ),
C                  AND USES NO TRANSCENDENTAL FUNCTION CALLS.
C                  THE LOCAL GRADIENTS ARE EVALUATED AS THE DIFFERENCE
C                  BETWEEN NEIGHBOURING TABLE VALUES DIVIDED BY THE
C                  TABLE INCREMENT FOR EACH DIMENSION.
C
C REFERENCE        SIGMA-0 L.U.T. CREATED BY PROGRAM LUTGEN (M1000).
C                  AND TESTED BY PROGRAM SIGTEST (M2000).
C
C VERSION          1.02  OCTOBER 1992  ORIG: D. OFFILER  SEP 89
C
C CHANGES          01  LUT FILE REFERENCED VIA LOGICAL NAME. D.O. APR 91
C                  02  ENHANCED LUT FILE.                    D.O. OCT 92
C
c Recieved by P.WOICESHYN for use & modification, JPL/NOAA FEB 19, 1993.
c
c

      IMPLICIT NONE

      INTEGER IPCHAN, NU, ND, NA
      REAL    FU, FD, FA, DU, DD, DA
      PARAMETER ( IPCHAN = 40 )
      PARAMETER ( NU =  30, ND =  37, NA =   46 )
      PARAMETER ( FU = 1.0, FD = 0.0, FA = 15.0 )
      PARAMETER ( DU = 1.0, DD = 5.0, DA =  1.0 )

C ARGUMENT LIST PARAMETERS

      REAL TSIGDB, U, D, A                

C LOCAL PARAMETERS

      CHARACTER MODEL*10, SIGFIL*10
      LOGICAL FIRST
      INTEGER STATUS, IU0, ID0, IA0, IU1, ID1, IA1
      REAL    DBLUT(NU,ND,NA)
      REAL    X, U0, D0, A0, RU0, RD0, RA0, RA1, RUD
      REAL    W0, X0, Y0, Z0, W1, X1, Y1, Z1

      COMMON / CMODEL / MODEL

      DATA SIGFIL / 'CMOD_DBLUT' /
      DATA FIRST  / .TRUE. /

C READ LOOK-UP TABLE ON FIRST ENTRY.

      IF ( FIRST ) THEN
c         OPEN  ( IPCHAN, FILE=SIGFIL, FORM='UNFORMATTED',
c     $            STATUS='OLD', IOSTAT=STATUS )
c         IF ( STATUS .NE. 0 ) THEN
c            PRINT *, '*** TSIGDB: Unable to open LUT file'
c            CALL EXIT
c         ENDIF
         READ  ( IPCHAN ) MODEL, DBLUT
c         CLOSE ( IPCHAN )
         FIRST = .FALSE.
      ENDIF

C FIND NEXT LOWER & NEXT HIGHER TABULATED ELEMENTS FOR EACH PARAMETER
C (RELATIVE DIRECTION 0-180 DEG ONLY, SINCE 180-360 IS SYMMETRICAL)

      X = ABS ( D )
   20 IF ( X .LE. 180.0 ) GOTO 30
         X = ABS ( X - SIGN ( 360.0, X ) )
         GOTO 20
   30 CONTINUE

      U0 = ( U - FU ) / DU + 1.0
      D0 = ( X - FD ) / DD + 1.0
      A0 = ( A - FA ) / DA + 1.0

      IU0 = MIN ( MAX ( INT ( U0 ), 1 ), NU - 1 )
      ID0 = MIN ( MAX ( INT ( D0 ), 1 ), ND - 1 )
      IA0 = MIN ( MAX ( INT ( A0 ), 1 ), NA - 1 )

      IU1 = IU0 + 1
      ID1 = ID0 + 1
      IA1 = IA0 + 1

C FIND OFFSETS FROM TABULATED VALUES

      RU0 = U0 - IU0
      RD0 = D0 - ID0
      RA1 = A0 - IA0
      RA0 = 1.0 - RA1
      RUD = RU0 * RD0

C INTERPOLATION COEFFICIENTS

      W0 = DBLUT(IU0,ID0,IA0)
      X0 = DBLUT(IU0,ID1,IA0) - W0
      Y0 = DBLUT(IU1,ID0,IA0) - W0    
      Z0 = DBLUT(IU1,ID1,IA0) - W0 - X0 - Y0

      W1 = DBLUT(IU0,ID0,IA1)
      X1 = DBLUT(IU0,ID1,IA1) - W1
      Y1 = DBLUT(IU1,ID0,IA1) - W1
      Z1 = DBLUT(IU1,ID1,IA1) - W1 - X1 - Y1

C INTERPOLATED BACKSCATTER VALUE

      TSIGDB = ( W0 + X0 * RD0 + Y0 * RU0 + Z0 * RUD ) * RA0
     $       + ( W1 + X1 * RD0 + Y1 * RU0 + Z1 * RUD ) * RA1

      END

C#######################################################################
C#######################################################################
C#######################################################################

      SUBROUTINE WINRET ( S0, AI, BA, KP, MS, PCD,
     1 VSOL, DSOL, RSOL, nvs )

C ROUTINE          WINRET  SUBROUTINE  R0001  VAXFORT  WINRET.FOR
C
C PURPOSE          SINGLE-CELL RANKED AMBIGUOUS WIND RETRIEVAL
C
C PROJECT          EDIPVS
C
C ARGUMENTS        S0    (ENTRY)  R4  3 MEASURED SIGMA-0 VALUES (DB)
C                  AI    (ENTRY)  R4  3 BEAM INCIDENCE ANGLES (DEG)
C                  BA    (ENTRY)  R4  3 BEAM AZIMUTH ANGLES (DEG)
C                  KP    (ENTRY)  R4  3 KP NOISE ESTIMATES (PERCENT)
C                  MS    (ENTRY)  I2  3 MISSING SHOT COUNTERS
C                  PCD   (ENT/EX) I2  PRODUCT CONFIDENCE FLAGS
C                  VSOL  (EXIT)   R4  4 RETRIEVED WIND SPEEDS (M/S)
C                  DSOL  (EXIT)   R4  4 RETRIEVED WIND DIRECTIONS (DEG)
C                  RSOL  (EXIT)   R4  4 RELATIVE PROBABILITY VALUES(0-1)
C
C SUBPROGRAMS      FIT3, QSPEED, RESID, RKONRES
C
C INTRINSICS       BTEST, IBSET, IBCLR, MAX, MIN
C
C DESCRIPTION      GIVEN A SET OF 3 SIGMA-0 MEASUREMENTS ASSOCIATED
C                  DATA, PERFORMS A SEARCH FOR LOCAL MINIMA IN RESIDUAL
C                  TO PRODUCE AN AMBIGUOUS SET OF WIND VECTOR
C                  RETRIEVALS. THESE ARE THEN RANKED IN ORDER OF
C                  PROBABILITY (BASED ON SOLUTION RESIDUAL).
C
C ALGORITHM        1) STEP OVER A COMPLETE 360 DEG IN WIND DIRECTION
C                     (PLUS SOME OVERLAP); FOR EACH STEP, ESTIMATE
C                     WIND SPEED DIRECTLY FROM SIGMA-0 TRIPLET & THENCE 
C                     SUM OF RESIDUALS VS. C-BAND MODEL.
C                  2) SEARCH OVER WIND DIRECTION FOR A LOCAL MINIMA IN 
C                     RESIDUAL.
C                  3) ACTUAL POSITION OF EACH MINIMUM (WIND DIRECTION)
C                     IS EST. FROM A QUADRATIC FITTED TO THE MINIMUM 
C                     AND THE TWO NEIGHBOURING RESIDUALS. THE SPEED 
C                     AND RESIDUALS ARE RE-ESTIMATED AT THIS POINT.
C                  4) REPEAT 2-3 UNTIL WHOLE CIRCLE SEARCHED OR FOUR
C                     MINIMA FOUND.
C                  5) CALCULATE PROBABILITY FOR EACH SOLUTION FROM
C                     RESIDUAL AT SOLUTION
C                  6) RANK THE SOLUTIONS IN DECREASING ORDER OF 
C                     PROBABILITY VALUES.
C                                                
C VERSION          1.09  JANUARY 1993  ORIG: D. OFFILER  SEP 89
C
C CHANGES          01  A) FIX TYPO ERROR SETTING RD(1).
C                      B) MAKE DD ARRAY LINEAR INSTEAD OF 0-360; THIS 
C                         WAS CAUSING MIMIMA DETECTED NEAR ZERO DEG. 
C                         TO GENERATE INCORRECT FIT3 COEFFICIENTS, AND 
C                         HENCE INCORRECT DIRECTION.
C                      C) REMOVE 'ANG360' CALL FOR IN-LINE CODE.
C                      D) CHECK KP LIMIT.                D.O.     JAN 91
C                  02  TUNE UPDATE ARC VALUES.           D.O.  21 AUG 91
C                  03  A) LIMIT RETRIEVED WIND SPEEDS TO VALID RANGE
C                         0.2 - 50.8 M/S
C                      B) SET AN INVALID SOLUTION IF FIT3 'C2' COEFF IS 
C                         ZERO (WAS SETTING SPEED/DIR TO ZEROS)
C                      C) ONLY CLEAR 'NO RETR' FLAG IF RK 1 GOOD.
C                                                        D.O.  21 OCT 91
C                  04  A) SET ALL SOLUTIONS MISSINGINITIALLY.
C                      B) ABORT PROCESSING EARLIER WHEN LAND SET.
C                      C) RE-SET ALL SOLUTIONS MISSING IF RK 1 NO GOOD.
C                                                        D.O.   4 NOV 91
C                  05  A) SET 'MISSING' RESIDUAL VALUES TO -9999.0
C                         INSTEAD OF -999.0.             D.O.   6 JAN 92
C                      B) IGNORE 'BEAM ARCING' FLAGS.    D.O.  10 JAN 92
C                      C) ASSUME MISSING KP'S = 10%.     D.O.  28 JAN 92
C                  06  NO LONGER SCALE RESIDUAL WITH KP. D.O.  21 JUL 92
C                  07  A) NO LONGER SCALE QSPEED WITH KP.
C                      B) NO SCALING AT ALL IN RESIDUAL, S0 LEFT
C                         IN DB; RSOL IS RETURNED AS RMS DIFF IN DB.
C                      C) SEARCH ALGORITHM MODIFIED; PERFORM CONSECUTIVE
C                         3-NEIGHBOUR CHECK INSTEAD OF SEARCHING FOR
C                         ABSOLUTE MINIMUM RESIDUAL WITHIN A `QUADRANT'.
C                      D) REJECT CASES WITH LARGE RSOL'S.
C                      E) ARC VALUE CALCULATED BY S/R RESARC.
C                                                        D.O.  19 OCT 92
C                  08  A) REDUCE KP THRESHOLD FROM 20% TO 10% (POOR
C                         SIGMA-0 VALUES ON FIRST ROW OF CELLS AFTER NEW
C                         START OF SWATH).
C                      B) RANK ON RSOL AS RELATIVE RESIDUAL PROBABILITES
C                         (DONE IN S/R RKONRES). ARC NOW AS RSOL(1)
C                      C) ONLY RETRIEVE 3-BEAM CASES WITH PCD=0
C                                                        D.O.  25 NOV 92
C                  09  SCAN FOR MINIMA WAS STOPPED BEFORE PENULTIMATE
C                      RESIDUAL IN ARRAY (330/345/360 DEG)- CORRECTED.
C                                                        D.O.   5 JAN 92
C
c Recieved by P.WOICESHYN for use & modification, JPL/NOAA FEB 19, 1993.
c
c

      IMPLICIT NONE

      INTEGER NB, NS, ND, NF
      REAL    DINC, KPLIM, VMIN, VMAX
      REAL    EPS, MTHRES
      PARAMETER ( NB = 3, NS = 4, ND = 26, NF = 3 )
      PARAMETER ( DINC = 15, KPLIM = 10.0, VMIN = 0.2, VMAX = 50.8 )
      PARAMETER ( EPS = 1.0E-7, MTHRES = 20 )

C ARGUMENT LIST PARAMETERS

      INTEGER MS(NB), PCD
      REAL      S0(NB), AI(NB), BA(NB), KP(NB)
      REAL      VSOL(NS), DSOL(NS), RSOL(NS)

C LOCAL PARAMETERS

      INTEGER ISTART(4)
      INTEGER IB, IS, ID, IRK1, MSTOT, NVS
      REAL    DD(ND), RD(ND), D3(NF), R3(NF)
      REAL    C0, C1, C2, RMAX, VG, DG
      REAL    QSPEED, RESID
                                         
C ASSUME KP'S OK, NO RETRIEVAL MADE & NO AMBIGUITY REMOVAL DONE;
C INITIALLY SET ALL SOLUTIONS TO 'MISSING' VALUES.

      PCD = IBCLR ( PCD,  6 )
      PCD = IBSET ( PCD,  8 )
      PCD = IBSET ( PCD,  9 )
      PCD = IBSET ( PCD, 11 )
      PCD = IBCLR ( PCD, 12 )
      PCD = IBCLR ( PCD, 13 )
      PCD = IBCLR ( PCD, 14 )

      VSOL(1:NS) =  51.0
      DSOL(1:NS) = 510.0 
      RSOL(1:NS) =   0.0

C CHECK KP'S; ABORT IF ANY BEAM MISSING OR ARCING OR KP ABOVE 
C THRESHOLD, OR CELL IS FLAGGED AS NOT SEA, OR FRAME CHECKSUM ERROR
C (ANY OF PCD BITS 1-8,11 SET) OR TOO MANY MISSING SHOTS.
cpw
cpw  Kp's and missing shots filtered in calling main program
cpw
cpw      MSTOT  = 0
cpw      DO IB = 1, NB
cpw         IF ( KP(IB) .LT. 0 .OR. KP(IB) .GT. KPLIM ) 
cpw     $      PCD = IBSET ( PCD, 6 )
cpw         MSTOT = MSTOT + ABS ( MS(IB) )
cpw      ENDDO
cpw      IF ( IAND ( PCD, '04FF'X ) .NE. 0 .OR.
cpw     $     MSTOT .GT. MTHRES ) RETURN

* ESTIMATE SPEED & HENCE RESIDUAL FOR SAMPLED SET OF DIRECTIONS OVER
* THE RANGE 0-345DEG; COPY 0 TO 360 AND 345 TO -15 TO GIVE SOME OVERLAP
* AROUND 0DEG.
      
      DG   = 0.0
      DO ID = 2, ND-1
         VG     = QSPEED ( DG, S0, AI, BA )
         DD(ID) = DG
         RD(ID) = RESID  ( VG, DG, S0, AI, BA )
         DG     = DG + DINC
      ENDDO
      DD(1)    = DD(ND-1) - 360.0
      RD(1)    = RD(ND-1)
      DD(ND)   = DD(2)    + 360.0
      RD(ND)   = RD(2)

C SEARCH FOR LOCAL RESIDUAL MINIMA

      ID   = 2
      IS   = 0
  210 CONTINUE  
         IF ( RD(ID) .LT. RD(ID-1) .AND.             
     $        RD(ID) .LT. RD(ID+1) ) THEN
 
C INTERPOLATE DIRECTION TO RESIDUAL MINIMUM WITH A QUADRATIC FIT
C TO THE THREE POINTS ABOUT THE MINIMUM. 

            D3(1) = DD(ID-1)
            D3(2) = DD(ID)
            D3(3) = DD(ID+1)
            R3(1) = RD(ID-1)
            R3(2) = RD(ID)
            R3(3) = RD(ID+1)
            CALL FIT3 ( D3, R3, C0, C1, C2 )

C DIRECTION ESTIMATE IS AT MINIMUM OF QUADRATIC FROM FIT3
C (IE dR/dD = 0 = C1 + 2*C2*D WHERE R = C0 + C1*D + C2*D**2);
C RE-ESTIMATE SPEED AT THIS SOLUTION.

            IF ( ABS ( C2 ) .GT. EPS ) THEN
               IS = IS + 1
               DSOL(IS) = AMOD ( -C1 / ( 2.0 * C2 ), 360.0 )
               IF ( DSOL(IS) .LT. 0.0 ) DSOL(IS) = DSOL(IS) + 360.0
               VSOL(IS) = QSPEED ( DSOL(IS), S0, AI, BA )
               VSOL(IS) = MIN    ( MAX ( VSOL(IS), VMIN ), VMAX )
               ID = ID + 1
            ENDIF
         ENDIF

         ID = ID + 1
         IF ( ID .LT. ND .AND. IS .LT. NS ) GOTO 210
C     END-CONTINUE-210

C RANK IN DECREASING ORDER OF (RELATIVE) PROBABILITY OF RESIDUALS
               
      CALL RKONRES ( VSOL, DSOL, RSOL, S0, AI, BA, KP, NVS, IRK1 )

C IF AT LEAST TWO PROBABLE SOLUTIONS, FLAG A RETRIEVAL DONE.
C IF ONLY ONE OR NO VALID SOLUTIONS (NONE RETRIEVED OR BEST SOLUTION 
C WAS OF LOW PROBABILITY), RESET ALL SOLUTIONS AS MISSING DATA.

      IF ( NVS .GE. 2 ) THEN
         PCD = IBCLR ( PCD, 11 )
      ELSE
         VSOL(1:NS) =  51.0
         DSOL(1:NS) = 510.0 
         RSOL(1:NS) =   0.0
      ENDIF

      END
